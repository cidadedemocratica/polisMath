<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{display:inline;font-size:34px;}h2.project-version{display:inline;margin-left:10px;margin-top:0;font-size:18px;}.toc-link{margin-left:10px;color:#252519;font-size:12px;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{margin:0;font-size:34px;}.docs-header{margin-bottom:25px;padding-bottom:10px;border-bottom:dotted #aaa 1px;}.toc h1{font-size:24px;}.toc{margin-bottom:40px;border-bottom:solid #bbb 1px;}.toc ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.toc li{padding-left:0;list-style-type:none;}.dependencies{}.dependencies table{border:none;width:99.99%;margin-left:20px;font-size:16px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.plugins li{padding-left:0;list-style-type:none;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;text-align:right;overflow:hidden;top:10px;right:20px;height:20px;}#floating-toc li{margin:0;padding:0;list-style-type:none;}</style><style type="text/css">body{margin:0;padding:0;color:#252519;font-size:16px;background-color:#F5F5FF;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;}h1{margin-top:0;font-size:20px;}h2{font-size:18px;}h3{font-size:16px;}a.anchor{color:#252519;text-decoration:none;}a.anchor:hover{color:#5050A6;}table{margin-bottom:10px;border-bottom:solid #ddd 1px;;border-spacing:0;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{border:none;margin:0px;padding-left:55px;width:410px;padding-right:20px;vertical-align:top;max-width:410px;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;background-color:ghostWhite;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*! jQuery v1.7.1 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){cl||(cl=c.createElement("iframe"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,"display"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function cb(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function ca(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bE.test(a)?d(a,e):ca(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)ca(a+"["+e+"]",b[e],c,d);else d(a,b)}function b_(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function b$(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bT,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=b$(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=b$(a,c,d,e,"*",g));return l}function bZ(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bP),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bC(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bx:by,g=0,h=e.length;if(d>0){if(c!=="border")for(;g<h;g++)c||(d-=parseFloat(f.css(a,"padding"+e[g]))||0),c==="margin"?d+=parseFloat(f.css(a,c+e[g]))||0:d-=parseFloat(f.css(a,"border"+e[g]+"Width"))||0;return d+"px"}d=bz(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0;if(c)for(;g<h;g++)d+=parseFloat(f.css(a,"padding"+e[g]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+e[g]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+e[g]))||0);return d+"px"}function bp(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c+(i[c][d].namespace?".":"")+i[c][d].namespace,i[c][d],i[c][d].data)}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.1",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?m(g):h==="function"&&(!a.unique||!o.has(g))&&c.push(g)},n=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,l=j||0,j=0,k=c.length;for(;c&&l<k;l++)if(c[l].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}i=!1,c&&(a.once?e===!0?o.disable():c=[]:d&&d.length&&(e=d.shift(),o.fireWith(e[0],e[1])))},o={add:function(){if(c){var a=c.length;m(arguments),i?k=c.length:e&&e!==!0&&(j=a,n(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){i&&f<=k&&(k--,f<=l&&l--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&o.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(i?a.once||d.push([b,c]):(!a.once||!e)&&n(b,c));return this},fire:function(){o.fireWith(this,arguments);return this},fired:function(){return!!e}};return o};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p,q=c.createElement("div"),r=c.documentElement;q.setAttribute("className","t"),q.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=q.getElementsByTagName("*"),e=q.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=q.getElementsByTagName("input")[0],b={leadingWhitespace:q.firstChild.nodeType===3,tbody:!q.getElementsByTagName("tbody").length,htmlSerialize:!!q.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:q.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete q.test}catch(s){b.deleteExpando=!1}!q.addEventListener&&q.attachEvent&&q.fireEvent&&(q.attachEvent("onclick",function(){b.noCloneEvent=!1}),q.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),q.appendChild(i),k=c.createDocumentFragment(),k.appendChild(q.lastChild),b.checkClone=k.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,k.removeChild(i),k.appendChild(q),q.innerHTML="",a.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",q.style.width="2px",q.appendChild(j),b.reliableMarginRight=(parseInt((a.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0);if(q.attachEvent)for(o in{submit:1,change:1,focusin:1})n="on"+o,p=n in q,p||(q.setAttribute(n,"return;"),p=typeof q[n]=="function"),b[o+"Bubbles"]=p;k.removeChild(q),k=g=h=j=q=i=null,f(function(){var a,d,e,g,h,i,j,k,m,n,o,r=c.getElementsByTagName("body")[0];!r||(j=1,k="position:absolute;top:0;left:0;width:1px;height:1px;margin:0;",m="visibility:hidden;border:0;",n="style='"+k+"border:5px solid #000;padding:0;'",o="<div "+n+"><div></div></div>"+"<table "+n+" cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",a=c.createElement("div"),a.style.cssText=m+"width:0;height:0;position:static;top:0;margin-top:"+j+"px",r.insertBefore(a,r.firstChild),q=c.createElement("div"),a.appendChild(q),q.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",l=q.getElementsByTagName("td"),p=l[0].offsetHeight===0,l[0].style.display="",l[1].style.display="none",b.reliableHiddenOffsets=p&&l[0].offsetHeight===0,q.innerHTML="",q.style.width=q.style.paddingLeft="1px",f.boxModel=b.boxModel=q.offsetWidth===2,typeof q.style.zoom!="undefined"&&(q.style.display="inline",q.style.zoom=1,b.inlineBlockNeedsLayout=q.offsetWidth===2,q.style.display="",q.innerHTML="<div style='width:4px;'></div>",b.shrinkWrapBlocks=q.offsetWidth!==2),q.style.cssText=k+m,q.innerHTML=o,d=q.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,i={doesNotAddBorder:e.offsetTop!==5,doesAddBorderForTableAndCells:h.offsetTop===5},e.style.position="fixed",e.style.top="20px",i.fixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",i.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,i.doesNotIncludeMarginInBodyOffset=r.offsetTop!==j,r.removeChild(a),q=a=null,f.extend(b,i))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h=null;if(typeof a=="undefined"){if(this.length){h=f.data(this[0]);if(this[0].nodeType===1&&!f._data(this[0],"parsedAttrs")){e=this[0].attributes;for(var i=0,j=e.length;i<j;i++)g=e[i].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),l(this[0],g,h[g]));f._data(this[0],"parsedAttrs",!0)}}return h}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split("."),d[1]=d[1]?"."+d[1]:"";if(c===b){h=this.triggerHandler("getData"+d[1]+"!",[d[0]]),h===b&&this.length&&(h=f.data(this[0],a),h=l(this[0],a,h));return h===b&&d[1]?this.data(d[0]):h}return this.each(function(){var b=f(this),e=[d[0],c];b.triggerHandler("setData"+d[1]+"!",e),f.data(this,a,c),b.triggerHandler("changeData"+d[1]+"!",e)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise()}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.nodeName.toLowerCase()]||f.valHooks[g.type];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;h<g;h++)e=d[h],e&&(c=f.propFix[e]||e,f.attr(a,e,""),a.removeAttribute(v?e:c),u.test(e)&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/\bhover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};
f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=[],j,k,l,m,n,o,p,q,r,s,t;g[0]=c,c.delegateTarget=this;if(e&&!c.target.disabled&&(!c.button||c.type!=="click")){m=f(this),m.context=this.ownerDocument||this;for(l=c.target;l!=this;l=l.parentNode||this){o={},q=[],m[0]=l;for(j=0;j<e;j++)r=d[j],s=r.selector,o[s]===b&&(o[s]=r.quick?H(l,r.quick):m.is(s)),o[s]&&q.push(r);q.length&&i.push({elem:l,matches:q})}}d.length>e&&i.push({elem:this,matches:d.slice(e)});for(j=0;j<i.length&&!c.isPropagationStopped();j++){p=i[j],c.currentTarget=p.elem;for(k=0;k<p.matches.length&&!c.isImmediatePropagationStopped();k++){r=p.matches[k];if(h||!c.namespace&&!r.namespace||c.namespace_re&&c.namespace_re.test(r.namespace))c.data=r.data,c.handleObj=r,n=((f.event.special[r.origType]||{}).handle||r.handler).apply(p.elem,g),n!==b&&(c.result=n,n===!1&&(c.preventDefault(),c.stopPropagation()))}}return c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0)}),d._submit_attached=!0)})},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on.call(this,a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.type+"."+e.namespace:e.type,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.POS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function()
{for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bp)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||!bc.test("<"+a.nodeName)?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=bg[l]||bg._default,n=m[0],o=b.createElement("div");b===c?bh.appendChild(o):U(b).appendChild(o),o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bn(k[i]);else bn(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||be.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bq=/alpha\([^)]*\)/i,br=/opacity=([^)]*)/,bs=/([A-Z]|^ms)/g,bt=/^-?\d+(?:px)?$/i,bu=/^-?\d/,bv=/^([\-+])=([\-+.\de]+)/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Left","Right"],by=["Top","Bottom"],bz,bA,bB;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bz(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bv.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bz)return bz(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return bC(a,b,d);f.swap(a,bw,function(){e=bC(a,b,d)});return e}},set:function(a,b){if(!bt.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return br.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bq,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bq.test(g)?g.replace(bq,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bz(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bA=function(a,b){var c,d,e;b=b.replace(bs,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b)));return c}),c.documentElement.currentStyle&&(bB=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f===null&&g&&(e=g[b])&&(f=e),!bt.test(f)&&bu.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f||0,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),bz=bA||bB,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bD=/%20/g,bE=/\[\]$/,bF=/\r?\n/g,bG=/#.*$/,bH=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bI=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bJ=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bK=/^(?:GET|HEAD)$/,bL=/^\/\//,bM=/\?/,bN=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bO=/^(?:select|textarea)/i,bP=/\s+/,bQ=/([?&])_=[^&]*/,bR=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bS=f.fn.load,bT={},bU={},bV,bW,bX=["*/"]+["*"];try{bV=e.href}catch(bY){bV=c.createElement("a"),bV.href="",bV=bV.href}bW=bR.exec(bV.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bS)return bS.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bN,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bO.test(this.nodeName)||bI.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bF,"\r\n")}}):{name:b.name,value:c.replace(bF,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b_(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b_(a,b);return a},ajaxSettings:{url:bV,isLocal:bJ.test(bW[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bX},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bZ(bT),ajaxTransport:bZ(bU),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?cb(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cc(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bH.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bG,"").replace(bL,bW[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bP),d.crossDomain==null&&(r=bR.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bW[1]&&r[2]==bW[2]&&(r[3]||(r[1]==="http:"?80:443))==(bW[3]||(bW[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),b$(bT,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bK.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bM.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bQ,"$1_="+x);d.url=y+(y===d.url?(bM.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bX+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=b$(bU,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)ca(g,a[g],c,e);return d.join("&").replace(bD,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cd=f.now(),ce=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cd++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ce.test(b.url)||e&&ce.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ce,l),b.url===j&&(e&&(k=k.replace(ce,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cf=a.ActiveXObject?function(){for(var a in ch)ch[a](0,1)}:!1,cg=0,ch;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ci()||cj()}:ci,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cf&&delete ch[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cg,cf&&(ch||(ch={},f(a).unload(cf)),ch[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var ck={},cl,cm,cn=/^(?:toggle|show|hide)$/,co=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cp,cq=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cr;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cu("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cv(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cu("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cu("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cv(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cn.test(h)?(o=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),o?(f._data(this,"toggle"+i,o==="show"?"hide":"show"),j[o]()):j[h]()):(k=co.exec(h),l=j.cur(),k?(m=parseFloat(k[2]),n=k[3]||(f.cssNumber[i]?"":"px"),n!=="px"&&(f.style(this,i,(m||1)+n),l=(m||1)/j.cur()*l,f.style(this,i,l+n)),k[1]&&(m=(k[1]==="-="?-1:1)*m+l),j.custom(l,m,n)):j.custom(l,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:cu("show",1),slideUp:cu("hide",1),slideToggle:cu("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cr||cs(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){e.options.hide&&f._data(e.elem,"fxshow"+e.prop)===b&&f._data(e.elem,"fxshow"+e.prop,e.start)},h()&&f.timers.push(h)&&!cp&&(cp=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cr||cs(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cp),cp=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(["width","height"],function(a,b){f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cy(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.support.fixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.support.fixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cy(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cy(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,d,"padding")):this[d]():null},f.fn["outer"+c]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,d,a?"margin":"border")):this[d]():null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNumeric(j)?j:i}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>polismath -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">polismath</h1><h2 class="project-version">0.1.0-SNAPSHOT</h2><br />
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">commons-collections/commons-collections</td><td class="dotted"><hr /></td><td class="dep-version">3.2.1</td></tr><tr><td class="dep-name">cheshire</td><td class="dotted"><hr /></td><td class="dep-version">5.3.1</td></tr><tr><td class="dep-name">org.clojure/tools.reader</td><td class="dotted"><hr /></td><td class="dep-version">0.8.13</td></tr><tr><td class="dep-name">com.taoensso/timbre</td><td class="dotted"><hr /></td><td class="dep-version">4.2.1</td></tr><tr><td class="dep-name">net.mikera/core.matrix</td><td class="dotted"><hr /></td><td class="dep-version">0.23.0</td></tr><tr><td class="dep-name">net.mikera/core.matrix.stats</td><td class="dotted"><hr /></td><td class="dep-version">0.3.0</td></tr><tr><td class="dep-name">net.mikera/vectorz-clj</td><td class="dotted"><hr /></td><td class="dep-version">0.19.0</td></tr><tr><td class="dep-name">criterium</td><td class="dotted"><hr /></td><td class="dep-version">0.4.2</td></tr><tr><td class="dep-name">clj-http</td><td class="dotted"><hr /></td><td class="dep-version">2.0.0</td></tr><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.5.1</td></tr><tr><td class="dep-name">org.clojure/core.async</td><td class="dotted"><hr /></td><td class="dep-version">0.1.303.0-886421-alpha</td></tr><tr><td class="dep-name">org.clojure/data.csv</td><td class="dotted"><hr /></td><td class="dep-version">0.1.2</td></tr><tr><td class="dep-name">org.clojure/math.numeric-tower</td><td class="dotted"><hr /></td><td class="dep-version">0.0.4</td></tr><tr><td class="dep-name">org.clojure/core.match</td><td class="dotted"><hr /></td><td class="dep-version">0.2.1</td></tr><tr><td class="dep-name">org.clojure/tools.namespace</td><td class="dotted"><hr /></td><td class="dep-version">0.2.7</td></tr><tr><td class="dep-name">org.clojure/tools.logging</td><td class="dotted"><hr /></td><td class="dep-version">0.3.0</td></tr><tr><td class="dep-name">org.clojure/tools.trace</td><td class="dotted"><hr /></td><td class="dep-version">0.7.6</td></tr><tr><td class="dep-name">ring/ring-core</td><td class="dotted"><hr /></td><td class="dep-version">1.4.0</td></tr><tr><td class="dep-name">ring-jetty-component</td><td class="dotted"><hr /></td><td class="dep-version">0.2.3</td></tr><tr><td class="dep-name">ring-basic-authentication</td><td class="dotted"><hr /></td><td class="dep-version">1.0.5</td></tr><tr><td class="dep-name">ring/ring-ssl</td><td class="dotted"><hr /></td><td class="dep-version">0.2.1</td></tr><tr><td class="dep-name">bidi</td><td class="dotted"><hr /></td><td class="dep-version">1.20.3</td></tr><tr><td class="dep-name">org.apache.storm/storm-core</td><td class="dotted"><hr /></td><td class="dep-version">0.9.2-incubating</td></tr><tr><td class="dep-name">bigml/sampling</td><td class="dotted"><hr /></td><td class="dep-version">2.1.0</td></tr><tr><td class="dep-name">incanter</td><td class="dotted"><hr /></td><td class="dep-version">1.5.4</td></tr><tr><td class="dep-name">com.novemberain/monger</td><td class="dotted"><hr /></td><td class="dep-version">3.0.1</td></tr><tr><td class="dep-name">amazonica</td><td class="dotted"><hr /></td><td class="dep-version">0.3.34</td></tr><tr><td class="dep-name">com.fasterxml.jackson.core/jackson-core</td><td class="dotted"><hr /></td><td class="dep-version">2.5.3</td></tr><tr><td class="dep-name">com.fasterxml.jackson.core/jackson-databind</td><td class="dotted"><hr /></td><td class="dep-version">2.5.3</td></tr><tr><td class="dep-name">org.postgresql/postgresql</td><td class="dotted"><hr /></td><td class="dep-version">9.2-1004-jdbc4</td></tr><tr><td class="dep-name">korma</td><td class="dotted"><hr /></td><td class="dep-version">0.3.0-RC5</td></tr><tr><td class="dep-name">clj-time</td><td class="dotted"><hr /></td><td class="dep-version">0.6.0</td></tr><tr><td class="dep-name">clj-excel</td><td class="dotted"><hr /></td><td class="dep-version">0.0.1</td></tr><tr><td class="dep-name">semantic-csv</td><td class="dotted"><hr /></td><td class="dep-version">0.1.0</td></tr><tr><td class="dep-name">dk.ative/docjure</td><td class="dotted"><hr /></td><td class="dep-version">1.8.0</td></tr><tr><td class="dep-name">prismatic/plumbing</td><td class="dotted"><hr /></td><td class="dep-version">0.2.2</td></tr><tr><td class="dep-name">environ</td><td class="dotted"><hr /></td><td class="dep-version">0.4.0</td></tr><tr><td class="dep-name">org.clojure/test.check</td><td class="dotted"><hr /></td><td class="dep-version">0.7.0</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#"></a></li><li><a href="#polismath.components.config">polismath.components.config</a></li><li><a href="#polismath.components.core-matrix-boot">polismath.components.core-matrix-boot</a></li><li><a href="#polismath.components.env">polismath.components.env</a></li><li><a href="#polismath.components.logger">polismath.components.logger</a></li><li><a href="#polismath.components.mongo">polismath.components.mongo</a></li><li><a href="#polismath.components.postgres">polismath.components.postgres</a></li><li><a href="#polismath.components.random">polismath.components.random</a></li><li><a href="#polismath.conv-man">polismath.conv-man</a></li><li><a href="#polismath.darwin.email">polismath.darwin.email</a></li><li><a href="#polismath.darwin.export">polismath.darwin.export</a></li><li><a href="#polismath.darwin.server">polismath.darwin.server</a></li><li><a href="#polismath.email">polismath.email</a></li><li><a href="#polismath.math.clusters">polismath.math.clusters</a></li><li><a href="#polismath.math.conversation">polismath.math.conversation</a></li><li><a href="#polismath.math.named-matrix">polismath.math.named-matrix</a></li><li><a href="#polismath.math.pca">polismath.math.pca</a></li><li><a href="#polismath.math.repness">polismath.math.repness</a></li><li><a href="#polismath.math.stats">polismath.math.stats</a></li><li><a href="#polismath.meta.intercom">polismath.meta.intercom</a></li><li><a href="#polismath.meta.metrics">polismath.meta.metrics</a></li><li><a href="#polismath.meta.microscope">polismath.meta.microscope</a></li><li><a href="#polismath.meta.simulation">polismath.meta.simulation</a></li><li><a href="#polismath.runner">polismath.runner</a></li><li><a href="#polismath.stormspec">polismath.stormspec</a></li><li><a href="#polismath.system">polismath.system</a></li><li><a href="#polismath.util.pretty-printers">polismath.util.pretty-printers</a></li><li><a href="#polismath.utils">polismath.utils</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">{mikera.vectorz.Vector clojure.core.matrix/matrix
 mikera.arrayz.NDArray clojure.core.matrix/matrix
 mikera.matrixx.Matrix clojure.core.matrix/matrix
 polismath.named-matrix.NamedMatrix polismath.named-matrix/named-matrix-reader}</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.components.config" name="polismath.components.config"><h1 class="project-name">polismath.components.config</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.components.config
  (:require [polismath.utils :as utils]
            [clojure.tools.logging :as log]
            [com.stuartsierra.component :as component]
            [environ.core :as environ]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -&gt;long [x]
  (try
    (Long/parseLong x)
    (catch Exception e
      (when-not (= x )
        ;; Otherwise, assume nil was intended...
        (log/warn &quot;Failed to parse -&gt;long:&quot; x))
      nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -&gt;keyword [x]
  ;; Otherwise want to return nil, so merging works
  (when (and x (not (= x )))
    (keyword x)))</pre></td></tr><tr><td class="docs"><p>XXX This should be computed; that is be a function of the rules.
:default specification should be in the rules themselves</p>
</td><td class="codes"><pre class="brush: clojure">(def defaults
  {:nrepl-port 12345
   :math-env   :dev
   :darwin     {:server-port 3123}
   ;; XXX Hmm... How do we express a dependency here?
   :primary-polis-url :localhost ;; Must do it in the component load...
   :database   {:pool-size 3}
   :math-schema-date &quot;2014_08_22&quot;
   :export     {:expiry-days 10}
   :storm      {:execution    :local
                :cluster-name &quot;polis-cluster&quot;
                :workers      3
                :spouts {:votes {:polling-interval 2000}
                         :moderation {:polling-interval 5000}}
                }
   :math       {:matrix-implementation :vectorz}
   :logging    {:file &quot;log/dev.log&quot;
                :level :info}
   })</pre></td></tr><tr><td class="docs"><p>Mapping of env keys to parsing options</p>
</td><td class="codes"><pre class="brush: clojure">(def rules
  {:nrepl-port                 {:parse -&gt;long}
   :math-env                   {:parse -&gt;keyword}
   ;; Have to use :port since that's what heroku expects...
   :port                       {:path [:darwin :server-port] :parse -&gt;long}
   :database-url               {:path [:database :url]}
   :database-for-reads-name    {:path [:database :reads-name]}
   :database-pool-size         {:path [:database :pool-size] :parse -&gt;long}
   :mongolab-uri               {:path [:mongo :url]}
   :mailgun-api-key            {:path [:email :api-key]}
   :mailgun-url                {:path [:email :url]}
   :primary-polis-url          {:path [:email :api-key]}
   :math-matrix-implementation {:path [:math :matrix-implementation] :parse -&gt;keyword}
   :math-cutoff-medium         {:path [:math :cutoffs :medium] :parse -&gt;long
                                :doc &quot;This is the maximum size of a conversation before running in :medium mode&quot;}
   :math-cutoff-large          {:path [:math :cutoffs :large] :parse -&gt;long
                                :doc &quot;This is the maximum size of a conversation before running in :large mode&quot;}
   :math-cutoff-max-ptpts      {:path [:math :cutoffs :max-ptpts] :parse -&gt;long
                                :doc &quot;This is the maximum number of participants before the conversation stops accepting new participants&quot;}
   :math-cutoff-max-cmnts      {:path [:math :cutoffs :max-ptpts] :parse -&gt;long
                                :doc &quot;This is the maximum number of comments before the conversation stops accepting new comments&quot;}
   :math-schema-date           {:doc &quot;This helps us version our mongo buckets.&quot;}
   ;; Should change these to be more abstract in key name; not hostedgraphite-apikey; just graphite-apikey etc XXX
   :hostedgraphite-apikey      {:path [:meta :graphite :api-key]
                                :doc &quot;API key for graphite db (perf monitoring)&quot;}
   :hostedgraphite-hostname    {:path [:meta :graphite :hostname]
                                :doc &quot;The hostname for sending messages to graphite&quot;}
   :export-expiry-days         {:path [:export :expiry-days] :parse -&gt;long
                                :doc &quot;The number of days before a mongo record representing a data exports gets removed&quot;}
   :vote-polling-interval      {:parse -&gt;long :path [:storm :spouts :votes :polling-interval]
                                :doc &quot;The polling interval for votes, in milliseconds&quot;}
   :mod-polling-interval       {:parse -&gt;long :path [:storm :spouts :moderation :polling-interval]
                                :doc &quot;The polling interval for moderation, in milliseconds&quot;}
   ;; Need to think more about the semantics of a recompute; once; always; only if not booted; etc? XXX
   :recompute                  {:parse boolean
                                :doc &quot;Whether or not to perform a recompute&quot;}
   ;; Need to think about how to handle options
   :storm-execution            {:path [:storm :execution] :options [:local :distributed] :parse -&gt;keyword
                                :doc &quot;Whether to run storm as a distributed cluster (StormSubmitter) or in local mode (LocalCluster)&quot;}
   :storm-cluster-name         {:path [:storm :cluster-name]
                                :doc &quot;Name of the cluster to run on in distributed mode&quot;}
   :storm-workers              {:path [:storm :workers] :parse -&gt;long
                                :doc &quot;Number of storm cluster workers for distributed mode&quot;}
   :logging-level              {:path [:logging :level] :parse -&gt;keyword
                                :doc &quot;Logging level for timbre; info, debug, error, etc&quot;}
   :logging-file               {:path [:logging :file]
                                :doc &quot;If set, a file to which the log will be appended&quot;}
   ;; XXX TODO &amp; Thoughts
   ;; Mini batch sizes (see polismath.math.conversation)
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-environ-config [rules env]
  (reduce
    (fn [config [name {:keys [parse path] :or {parse identity}}]]
      (if-let [env-var-val (get env name)]
        (assoc-in config (or path [name]) (parse env-var-val))
        config))
    {}
    rules))</pre></td></tr><tr><td class="docs"><p>Like merge, but merges maps recursively.</p>
</td><td class="codes"><pre class="brush: clojure">(defn deep-merge
  [&amp; maps]
  (if (every? #(or (map? %) (nil? %)) maps)
    (apply merge-with deep-merge maps)
    (last maps)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-config
  ([overrides]
   (deep-merge defaults
               ;(read-string (slurp &quot;config.edn&quot;))
               (get-environ-config rules environ/env)
               overrides))
  ([] (get-config {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Config [overrides]
  component/Lifecycle
  (start [component]
    (log/info &quot;Starting config component&quot;)
    (into component (get-config overrides)))
  (stop [component]
    component))</pre></td></tr><tr><td class="docs"><p>Create a new instance of a Config component, with config-overrides.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-config
  ([config-overrides]
   (Config. config-overrides))
  ([] (create-config {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.components.core-matrix-boot" name="polismath.components.core-matrix-boot"><h1 class="project-name">polismath.components.core-matrix-boot</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.components.core-matrix-boot
  (:require [polismath.utils :as utils]
            [clojure.core.matrix :as matrix]
            [clojure.tools.logging :as log]
            [com.stuartsierra.component :as component]
            [cheshire.generate :refer [add-encoder encode-seq remove-encoder]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn matrix-encoder
  [v jsonGenerator]
  (encode-seq (into-array v) jsonGenerator))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def matrix-types [mikera.vectorz.Vector
                   ;; XXX Need to figure out why this doesn't exist yet
                   ;clojure.core.matrix.impl.ndarray.NDArray
                   ])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord CoreMatrixBooter [config]
  component/Lifecycle
  ;; Load the matrix implementation and create a dummy matrix to ensure classes get loaded properly.
  (start [component]
    (let [implementation (get-in config [:math :matrix-implementation])]
      (log/info &quot;Starting CoreMatrixBooter with implementation:&quot; implementation)
      (matrix/set-current-implementation implementation)
      (matrix/matrix [[1 2 3] [4 5 6]])
      ;; Adding encoders so things work properly with serialization
      (doseq [t matrix-types]
        (add-encoder t matrix-encoder)))
    component)
  (stop [component]
    (log/info &quot;Stopping CoreMatrixBooter&quot;)
    (doseq [t matrix-types]
      (remove-encoder t))
    component))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-core-matrix-booter []
  (map-&gt;CoreMatrixBooter {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.components.env" name="polismath.components.env"><h1 class="project-name">polismath.components.env</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.components.env
  (:require [environ.core :as environ]))</pre></td></tr><tr><td class="docs"><p>Deprecating... Will remove by the end of refactor XXX</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic env environ/env)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-env-overrides
  [overrides &amp; body]
  `(binding [env (merge env ~overrides)]
     ~@body))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.components.logger" name="polismath.components.logger"><h1 class="project-name">polismath.components.logger</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.components.logger
  (:require [com.stuartsierra.component :as component]
            [taoensso.timbre :as timbre]
            [taoensso.timbre.appenders.core :as appenders]))</pre></td></tr><tr><td class="docs"><p>XXX Hmmm.. this doesn't seem to be working yet. Maybe we need to use timbre for log calls instead of
clojure.tools.logging</p>
</td><td class="codes"><pre class="brush: clojure">(defrecord Logger [config]
  component/Lifecycle
  (start [component]
    (timbre/merge-config!
      {;:middleware [] ; (fns [data]) -&gt; ?data, applied left-&gt;right
       ;:timestamp-opts default-timestamp-opts ; {:pattern _ :locale _ :timezone _}
       ;:output-fn default-output-fn ; (fn [data]) -&gt; string
       :appenders {:println-appender
                   {:enabled?   true
                    :async?     false
                    :min-level  nil
                    :rate-limit [[1 250] [10 5000]] ; 1/250ms, 10/5s
                    :output-fn  :inherit
                    :fn ; Appender's fn
                    (fn [data]
                      (let [{:keys [output-fn]} data
                            formatted-output-str (output-fn data)]
                        (println formatted-output-str)))}
                   :file-appender
                   {:spit (appenders/spit-appender {:fname &quot;/path/my-file.log&quot;})}}})
    (timbre/merge-config!
      (:logging config)))
  (stop [component]
    component))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-logger []
  (map-&gt;Logger {}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.components.mongo" name="polismath.components.mongo"><h1 class="project-name">polismath.components.mongo</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.components.mongo
  (:require [polismath.utils :as utils]
            [clojure.tools.logging :as log]
            [com.stuartsierra.component :as component]
            [cheshire.core :as ch]
            [monger.core :as mg]
            [monger.collection :as mc]))</pre></td></tr><tr><td class="docs"><p>Mongo collection name based on math-env and math-schema-date config variables. Makes sure that
  prod, preprod, dev (and subdevs like chrisdev or mikedev) have their own noninterfering collections.</p>
</td><td class="codes"><pre class="brush: clojure">(defn collection-name
  ([mongo rootname]
   (let [{:keys [math-schema-date math-env]} (:config mongo)]
     (str rootname &quot;_&quot; math-env &quot;_&quot; math-schema-date)))
  ([mongo rootname basename] (str (collection-name mongo rootname) basename)))</pre></td></tr><tr><td class="docs"><p>As in collection-name function, with rootname bound to 'math'; used for actual math results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn math-collection-name
  [mongo basename]
  (collection-name mongo &quot;math&quot; basename))</pre></td></tr><tr><td class="docs"><p>As in collection-name function, with rootname bound to 'math'; used for actual math results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn exports-collection-name
  [mongo]
  (collection-name mongo &quot;exports&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- megabytes
  [^long n]
  (* n 1024 1024))</pre></td></tr><tr><td class="docs"><p>Connects either to (-> config :mongo :url), or a local temp mongo db if nil, and assocs in the connection
  and db to the mongo record as the return value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-connection-and-db!
  [{:keys [config] :as mongo}]
  (merge mongo
         (if-let [mongo-url (-&gt; config :mongo :url)]
           (mg/connect-via-uri mongo-url)
           (let [conn (mg/connect)]
             {:conn conn :db (mg/get-db conn &quot;local-db&quot;)}))))</pre></td></tr><tr><td class="docs"><p>Sets up the rolling profile collection, if not already present in the mongo db. Returns mongo for
  threading convenience.</p>
</td><td class="codes"><pre class="brush: clojure">(defn setup-rolling-profile-collection!
  [{:keys [db] :as mongo}]
  (let [prof-coll (math-collection-name mongo &quot;profile&quot;)]
    (if-not (mc/exists? db prof-coll)
      (try
        (mc/create db prof-coll {:capped true :size (-&gt; 125 megabytes) :max 200000})
        (catch Exception e
          (log/warn &quot;Unable to create capped profile collection. Perhaps it's already been created?&quot;)))))
  mongo)</pre></td></tr><tr><td class="docs"><p>Set up zid indices for upserting and more efficient queries. Also create expiring index for export records.</p>
</td><td class="codes"><pre class="brush: clojure">(defn setup-indices!
  [{:keys [config db] :as mongo}]
  ; Create indices, in case they don't exist
  (doseq [c (map (partial math-collection-name mongo)
                 [&quot;bidtopid&quot; &quot;main&quot; &quot;cache&quot;])]
    (mc/ensure-index db c (array-map :zid 1) {:name (str c &quot;_zid_index&quot;) :unique true}))
  ;; An index for lastupdated on &quot;exports&quot; collection
  (mc/ensure-index db (exports-collection-name mongo) {:lastupdate 1} {:expireAfterSeconds (-&gt; config :export :expiry-days (* 60 60 24))})
  mongo)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Mongo [config conn db]
  component/Lifecycle
  (start [component]
    (log/info &quot;Starting Mongo component&quot;)
    (if-not (and conn db)
      (-&gt; component
          get-connection-and-db!
          setup-rolling-profile-collection!
          setup-indices!)
      component))
  (stop [component]
    (log/info &quot;Stopping Mongo component&quot;)
    (mg/disconnect conn)
    (assoc component :conn nil :db nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-mongo []
  (map-&gt;Mongo {}))</pre></td></tr><tr><td class="docs"><p>Public API</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Very bare bones reloading of the conversation; no cleanup for keyword/int hash-map key mismatches,
  as found in the :repness</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-conv
  [mongo zid]
  (mc/find-one-as-map
    (:db mongo)
    (collection-name (:config mongo) &quot;main&quot;)
    {:zid zid}))</pre></td></tr><tr><td class="docs"><p>Formats data for mongo, first passing through a prep function which may strip out uneeded junk or
  reshape things. Takes conv and lastVoteTimestamp, though the latter may be moved into the former in update</p>
</td><td class="codes"><pre class="brush: clojure">(defn format-for-mongo
  [conv]
  (-&gt; conv
      ; core.matrix &amp; monger workaround: convert to str with cheshire then back
      ch/generate-string
      ch/parse-string))</pre></td></tr><tr><td class="docs"><p>Perform upsert of new results on mongo collection name based on :zid of new-results</p>
</td><td class="codes"><pre class="brush: clojure">(defn zid-upsert
  [mongo collection-name new-results]
  (mc/update
    (:db mongo)
    collection-name
    {:zid (or (:zid new-results) ; covering our bases for strings or keywords due to cheshire hack
              (get new-results &quot;zid&quot;))}
    new-results
    {:upsert true}))</pre></td></tr><tr><td class="docs"><p>Perform insert to mongo collection</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert
  [mongo collection-name object]
  (mc/insert
    (:db mongo)
    collection-name
    object))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.components.postgres" name="polismath.components.postgres"><h1 class="project-name">polismath.components.postgres</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.components.postgres
  (:require [polismath.components.env :as env]
            [polismath.util.pretty-printers :as pp]
            [polismath.utils :as utils]
            ;; Replace with as util XXX
            ;[polismath.utils :as utils :refer :all]
            [clojure.stacktrace :refer :all]
            [clojure.tools.logging :as log]
            [clojure.tools.trace :as tr]
            [com.stuartsierra.component :as component]
            [plumbing.core :as pc]
            [korma.core :as ko]
            [korma.db :as kdb]
            [cheshire.core :as ch]
            ;[alex-and-georges.debug-repl :as dbr]))</pre></td></tr><tr><td class="docs"><p>Create a korma db-spec given a heroku db-uri</p>
</td><td class="codes"><pre class="brush: clojure">(defn heroku-db-spec
  [db-uri]
  (let [[_ user password host port db] (re-matches #&quot;postgres://(?:(.+):(.*)@)?([^:]+)(?::(\d+))?/(.+)&quot; db-uri)
        settings {:user user
                  :password password
                  :host host
                  :port (or port 80)
                  :db db
                  :ssl true
                  :sslfactory &quot;org.postgresql.ssl.NonValidatingFactory&quot;}]
    (kdb/postgres settings)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Postgres [config db-spec]
  component/Lifecycle
  (start [component]
    (log/info &quot;Starting Postgres component&quot;)
    (let [db-spec (-&gt; config :database :url heroku-db-spec)]
      (assoc component :db-spec db-spec)))
  (stop [component]
    (log/info &quot;Stopping Postgres component&quot;)
    (assoc component :db-spec nil)))</pre></td></tr><tr><td class="docs"><p>Creates a new Postgres component</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-postgres
  []
  (map-&gt;Postgres {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare users conversations votes participants)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ko/defentity users
  (ko/pk :uid)
  (ko/entity-fields :uid :hname :username :email :is_owner :created :plan)
  (ko/has-many conversations)
  (ko/has-many votes))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ko/defentity conversations
  (ko/pk :zid)
  (ko/entity-fields :zid :owner)
  (ko/has-many votes)
  (ko/belongs-to users (:fk :owner)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ko/defentity votes
  (ko/entity-fields :zid :pid :tid :vote :created)
  (ko/belongs-to participants (:fk :pid))
  (ko/belongs-to conversations (:fk :zid)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ko/defentity participants
  (ko/entity-fields :pid :uid :zid :created)
  (ko/belongs-to users (:fk :uid))
  (ko/belongs-to conversations (:fk :zid)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ko/defentity comments
  (ko/entity-fields :zid :tid :mod :modified)
  (ko/belongs-to conversations  (:fk :zid)))</pre></td></tr><tr><td class="docs"><p>Query for all data since last-vote-timestamp, given a db-spec</p>
</td><td class="codes"><pre class="brush: clojure">(defn poll
  [component last-vote-timestamp]
  (try
    (kdb/with-db (:db-spec component)
      (ko/select votes
        (ko/where {:created [&gt; last-vote-timestamp]})
        (ko/order [:zid :tid :pid :created] :asc))) ; ordering by tid is important, since we rely on this ordering to determine the index within the comps, which needs to correspond to the tid
    (catch Exception e
      (log/error &quot;polling failed &quot; (.getMessage e))
      (.printStackTrace e)
      [])))</pre></td></tr><tr><td class="docs"><p>Moderation query: basically look for when things were last modified, since this is the only time they will
  have been moderated.</p>
</td><td class="codes"><pre class="brush: clojure">(defn mod-poll
  [component last-mod-timestamp]
  (try
    (kdb/with-db (:db-spec component)
      (ko/select comments
        (ko/fields :zid :tid :mod :modified)
        (ko/where {:modified [&gt; last-mod-timestamp]
                   :mod [not= 0]})
        (ko/order [:zid :tid :modified] :asc)))
    (catch Exception e
      (log/error &quot;moderation polling failed &quot; (.getMessage e))
      [])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def get-users
  (-&gt;
    (ko/select* users)
    (ko/fields :uid :hname :username :email :is_owner :created :plan)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def get-users-with-stats
  (-&gt;
    get-users
    (ko/fields :owned_convs.avg_n_ptpts
               :owned_convs.avg_n_visitors
               :owned_convs.n_owned_convs
               :owned_convs.n_owned_convs_ptptd
               :ptpt_summary.n_ptptd_convs)
    ; Join summary stats of owned conversations
    (ko/join :left
      [(ko/subselect
         conversations
         (ko/fields :owner)
         ; Join participant count summaries per conv
         (ko/join
           [(ko/subselect
              participants
              (ko/fields :zid)
              (ko/aggregate (count (ko/raw &quot;DISTINCT pid&quot;)) :n_visitors :zid))
            ; as visitor_summary
            :visitor_summary]
           (= :visitor_summary.zid :zid))
         (ko/join
           :left
           [(ko/subselect
              participants
              (ko/fields :participants.zid [(ko/raw &quot;COUNT(DISTINCT votes.pid) &gt; 0&quot;) :any_votes])
              (ko/join votes (and (= :votes.pid :participants.pid)
                                  (= :votes.zid :participants.zid)))
              (ko/aggregate (count (ko/raw &quot;DISTINCT votes.pid&quot;)) :n_ptpts :participants.zid))
            ; as ptpt_summary
            :ptpt_summary]
           (= :ptpt_summary.zid :zid))
         ; Average participant counts, and count number of conversations
         (ko/aggregate (avg :visitor_summary.n_visitors) :avg_n_visitors)
         (ko/aggregate (avg :ptpt_summary.n_ptpts) :avg_n_ptpts)
         (ko/aggregate (count (ko/raw &quot;DISTINCT conversations.zid&quot;)) :n_owned_convs)
         (ko/aggregate (sum (ko/raw &quot;CASE WHEN ptpt_summary.any_votes THEN 1 ELSE 0 END&quot;)) :n_owned_convs_ptptd)
         (ko/group :owner))
       ; as owned_convs
       :owned_convs]
      (= :owned_convs.owner :uid))
    ; Join summary stats on participation
    (ko/join
      :left
      [(ko/subselect
         participants
         (ko/fields :uid)
         (ko/aggregate (count (ko/raw &quot;DISTINCT zid&quot;)) :n_ptptd_convs :uid))
       :ptpt_summary]
      (= :ptpt_summary.uid :uid))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-users-by-uid
  [component uids]
  (kdb/with-db (:db-spec component)
    (-&gt;
      get-users-with-stats
      (ko/where (in :uid uids))
      (ko/select))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-users-by-email
  [component emails]
  (kdb/with-db (:db-spec component)
    (-&gt;
      get-users-with-stats
      (ko/where (in :email emails))
      (ko/select))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.components.random" name="polismath.components.random"><h1 class="project-name">polismath.components.random</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>This will eventually house a random number generator component which assists in the tracking of seed state</p>
</td><td class="codes"><pre class="brush: clojure">(ns polismath.components.random)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.conv-man" name="polismath.conv-man"><h1 class="project-name">polismath.conv-man</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>This is the namesascpe for the </p>
</td><td class="codes"><pre class="brush: clojure">(ns polismath.conv-man
  (:require [polismath.math.named-matrix :as nm]
            [polismath.math.conversation :as conv]
            [polismath.math.clusters :as clust]
            [polismath.meta.metrics :as met]
            [polismath.components.env :as env]
            [polismath.components.mongo :as mongo]
            [polismath.utils :as utils]
            [clojure.core.matrix.impl.ndarray]
            [clojure.core.async :as async :refer [go go-loop &lt;! &gt;! &lt;!! &gt;!! alts!! alts! chan dropping-buffer put! take!]]
            [clojure.tools.trace :as tr]
            [clojure.tools.logging :as log]
            [com.stuartsierra.component :as component]
            [plumbing.core :as pc]
            [schema.core :as s]))</pre></td></tr><tr><td class="docs"><p>Prep function for passing to db/format-for-mongo given bidToPid data</p>
</td><td class="codes"><pre class="brush: clojure">(defn prep-bidToPid
  [results]
  {:zid (:zid results)
   :bidToPid (:bid-to-pid results)
   :lastVoteTimestamp (:last-vote-timestamp results)})</pre></td></tr><tr><td class="docs"><p>Prep function for passing to db/format-for-mongo and on the main polismath collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defn prep-main
  [results]
  (-&gt; results
      ; REFORMAT BASE CLUSTERS
      (update-in [:base-clusters] clust/fold-clusters)
      ; Whitelist of keys to be included in sent data; removes intermediates
      (assoc :lastVoteTimestamp (:last-vote-timestamp results))
      (assoc :lastModTimestamp (:last-mod-timestamp results))
      (utils/hash-map-subset #{
        :base-clusters
        :group-clusters
        :in-conv
        :lastVoteTimestamp
        :lastModTimestamp
        :n
        :n-cmts
        :pca
        :repness
        :consensus
        :zid
        :user-vote-counts
        :votes-base
        :group-votes})))</pre></td></tr><tr><td class="docs"><p>For now, just log profile data. Eventually want to send to influxDB and graphite.</p>
</td><td class="codes"><pre class="brush: clojure">(defn handle-profile-data
  [conv-man conv &amp; {:keys [recompute n-votes finish-time] :as extra-data}]
  (if-let [prof-atom (:profile-data conv)]
    (let [prof @prof-atom
          tot (apply + (map second prof))
          prof (assoc prof :total tot)]
      (try
        (-&gt; prof
            (assoc :n-ptps (:n conv))
            (merge (utils/hash-map-subset conv #{:n-cmts :zid :last-vote-timestamp})
                   extra-data)
            (-&gt;&gt; (mongo/insert (:mongo conv-man) (mongo/math-collection-name &quot;profile&quot;))))
        (catch Exception e
          (log/warn &quot;Unable to submit profile data for zid:&quot; (:zid conv))
          (.printStackTrace e)))
      (log/debug &quot;Profile data for zid&quot; (:zid conv) &quot;: &quot; prof))))</pre></td></tr><tr><td class="docs"><p>A schema for what valid conversations should look like (WIP)</p>

<p>XXX WIP; need to flesh out and think about all the ins and outs
Also, should place this in conversation, but for now...</p>
</td><td class="codes"><pre class="brush: clojure">(def Conversation
  {:zid                 s/Int
   :last-vote-timestamp s/Int
   :group-votes         s/Any
   ;; Note: we let all other key-value pairs pass through
   s/Keyword            s/Any})</pre></td></tr><tr><td class="docs"><p>This function is what actually gets sent to the conv-actor. In addition to the conversation and vote batches
  up in the channel, we also take an error-callback. Eventually we'll want to pass opts through here as well.</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-fn
  [conv-man conv votes error-callback]
  (let [start-time (System/currentTimeMillis)
        mongo (:mongo conv-man)]
    (log/info &quot;Starting conversation update for zid:&quot; (:zid conv))
    (try
      ;; Need to expose opts for conv-update through config... XXX
      (let [updated-conv   (conv/conv-update conv votes)
            zid            (:zid updated-conv)
            finish-time    (System/currentTimeMillis)
            ; If this is a recompute, we'll have either :full or :reboot, ow/ want to send false
            recompute      (if-let [rc (:recompute conv)] rc false)]
        (log/info &quot;Finished computng conv-update for zid&quot; zid &quot;in&quot; (- finish-time start-time) &quot;ms&quot;)
        (handle-profile-data conv-man
                             updated-conv
                             :finish-time finish-time
                             :recompute recompute
                             :n-votes (count votes))
        ;; Make sure our data has the right shape
        (when-let [validation-errors (s/check Conversation updated-conv)]
          ;; XXX Should really be using throw+ (slingshot) here and throutout the code base
          ;; Also, should put in code for doing smart collapsing of collections...
          (log/error &quot;Validation error: Conversation value does not match schema for conv zid:&quot; zid)
          (throw (Exception. (str &quot;Validation error: Conversation Value does not match schema: &quot;
                                  validation-errors))))
        ; Format and upload main results
        (doseq [[col-name prep-fn] [[&quot;main&quot; prep-main] ; main math results, for client
                                    [&quot;bidtopid&quot; prep-bidToPid]]] ; bidtopid mapping, for server
          ;; XXX Hmmm... format-for-mongo should be abstracted so that it always get's called, and the prep
          ;; function gets taken care of separately; don't need to conplect these
          (-&gt;&gt; updated-conv
               prep-fn
               (mongo/zid-upsert mongo (mongo/collection-name mongo col-name))))
        (log/info &quot;Finished uploading mongo results for zid:&quot; zid)
        ; Return the updated conv
        updated-conv)
      ; In case anything happens, run the error-callback handler. Agent error handlers do not work here, since
      ; they don't give us access to the votes.
      (catch Exception e
        ;; XXX See comment below about decoupling errors
        (error-callback votes start-time (:opts' conv) e)
        ; Wait a second before returning the origin, unmodified conv, to throttle retries
        ;; XXX This shouldn't be here... ???
        (Thread/sleep 1000)
        conv))))</pre></td></tr><tr><td class="docs"><p>Maybe switch over to using this with arbitrary attrs map with zid and other data? XXX
(defmacro try-with-error-log
[zid message &amp; body]
`(try
~@body
(catch
(log/error ~message (str "(for zid=" ~zid ")")))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h3>Side notes on error handling</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Should be decoupling error handling from all of this mess; create it's own logic shoot and perhaps
component so we can look at inspect and reason about the error flow of the system.
Make it programatic; pure; not just a ad-hoc try/catch flow control thing coupled with the logic of the
application.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a closure that can be called in case there is an update error. The closure gives access to
  the queue so votes can be requeued</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-update-error-handler
  [conv-man queue conv]
  (fn [votes start-time opts update-error]
    (let [zid-str (str &quot;zid=&quot; (:zid conv))]
      (log/error &quot;Failed conversation update for&quot; zid-str)
      (.printStackTrace update-error)
      ; Try requeing the votes that failed so that if we get more, they'll get replayed
      ; XXX - this could lead to a recast vote being ignored, so maybe the sort should just always happen in
      ; the conv-actor update?
      (try
        (log/info &quot;Preparing to re-queue votes for failed conversation update for&quot; zid-str)
        ;; XXX Should we check if the queue got close due to error or manager close, and log?
        (async/go (async/&gt;! queue [:votes votes]))
        (catch Exception qe
          (log/error &quot;Unable to re-queue votes after conversation update failed for&quot; zid-str)
          (.printStackTrace qe)))
      ; Try to send some failed conversation time metrics, but don't stress if it fails
      (try
        (let [end (System/currentTimeMillis)
              duration (- end start-time)]
          ;; Update to use MetricSender component XXX
          (met/send-metric (:metrics conv-man) &quot;math.pca.compute.fail&quot; duration))
        (catch Exception e
          (log/error &quot;Unable to send metrics for failed compute for&quot; zid-str)))
      ; Try to save conversation state for debugging purposes
      (try
        (conv/conv-update-dump conv votes opts update-error)
        (catch Exception e
          (log/error &quot;Unable to perform conv-update dump for&quot; zid-str))))))</pre></td></tr><tr><td class="docs"><p>XXX This is really bad, now that I think of it. There should be a data-driven declarative specification of
what the shape of a conversation is, what is required, what needs to be modified etc, so everything is all
in one place. This problem with teh :lastVoteTimestamp and group-votes etc came up precisely because there
wasn't "one place to go" for modifying all of the potential points of interest for these kind of changes.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>XXX However, we shouldn't even be pushing the results to mongo if we didn't actually update anything</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn restructure-mongo-conv
  [conv]
  (-&gt; conv
      (utils/hash-map-subset #{:rating-mat :lastVoteTimestamp :zid :pca :in-conv :n :n-cmts :group-clusters :base-clusters :group-votes})
      (assoc :last-vote-timestamp (get conv :lastVoteTimestamp)
             :last-mod-timestamp  (get conv :lastModTimestamp))
      ; Make sure there is an empty named matrix to operate on
      (assoc :rating-mat (nm/named-matrix))
      ; Update the base clusters to be unfolded
      (update-in [:base-clusters] clust/unfold-clusters)
      ; Make sure in-conv is a set
      (update-in [:in-conv] set)))</pre></td></tr><tr><td class="docs"><p>Given a zid, either load a minimal set of information from mongo, or if a new zid, create a new conv</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-or-init
  [conv-man zid &amp; {:keys [recompute]}]
  (if-let [conv (and (not recompute) (mongo/load-conv (:mongo conv-man) zid))]
    (-&gt; conv
        restructure-mongo-conv
        (assoc :recompute :reboot))
    ; would be nice to have :recompute :initial
    (assoc (conv/new-conv) :zid zid :recompute :full)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro take-all! [c]
  &quot;Given a channel, takes all values currently in channel and places in a vector. Must be called
  within a go block.&quot;
  `(loop [acc# []]
     (let [[v# ~c] (alts! [~c] :default nil)]
       (if (not= ~c :default)
         (recur (conj acc# v#))
         acc#))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn take-all!! [c]
  &quot;Given a channel, takes all values currently in channel and places in a vector. Must be called
  within a go block.&quot;
  (loop [acc []]
    (let [[v c] (alts!! [c] :default nil)]
      (if (not= c :default)
        (recur (conj acc v))
        acc))))</pre></td></tr><tr><td class="docs"><p>This function splits message batches as sent to conv actor up by the first item in batch vector (:votes :moderation)
  so messages can get processed properly</p>
</td><td class="codes"><pre class="brush: clojure">(defn split-batches
  [messages]
  (-&gt;&gt; messages
       (group-by first)
       (pc/map-vals
         (fn [labeled-batches]
           (-&gt;&gt; labeled-batches
                (map second)
                (flatten))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ConversationManager [config mongo metrics conversations listeners]
  component/Lifecycle
  (start [component]
    (log/info &quot;Starting ConversationManager&quot;)
    (let [conversations (atom {})
          listeners (atom {})]
      (assoc component :conversations conversations :listeners listeners)))
  (stop [component]
    (log/info &quot;Stopping ConversationManager&quot;)
    ;; Close all our message channels for good measure
    (doseq [[zid {:keys [message-chan]}] @conversations]
      (async/close! message-chan))
    ;; Not sure, but we might want this for GC
    (reset! conversations nil)
    (reset! listeners nil)
    (assoc component :conversations nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-conversation-manager
  []
  (map-&gt;ConversationManager {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-listener!
  ([conv-man listener-fn]
   (add-listener! conv-man (rand-int 9999999) listener-fn))
  ([{:as conv-man :keys [listeners]} listener-key listener-fn]
   (swap! listeners assoc listener-key listener-fn)))</pre></td></tr><tr><td class="docs"><p>Need to think about what to do if failed conversations lead to messages piling up in the message queue XXX</p>
</td><td class="codes"><pre class="brush: clojure">(defn queue-message-batch!
  [{:as conv-man :keys [conversations config listeners]} message-type zid message-batch]
  (log/info &quot;Conversations is:&quot; conversations)
  (if-let [{:keys [conv message-chan]} (get @conversations zid)]
    ;; Then we already have a go loop running for this
    (&gt;!! message-chan {:message-type message-type :message-batch message-batch})
    ;; Then we need to initialize the conversation and set up the conversation channel and go routine
    (let [_ (log/info &quot;Starting message batch queue and handler routine for conv zid:&quot; zid)
          conv (load-or-init conv-man zid :recompute (:recompute config))
          _ (log/info &quot;Conversation loaded for conv zid:&quot; zid)
          ;; XXX Need to set up message chan buffer as a env var
          message-chan (chan 100000)]
      (swap! conversations assoc zid {:conv conv :message-chan message-chan})
      ;; Just call again to make sure the message gets on the chan :-)
      (queue-message-batch! conv-man message-type zid message-batch)
      ;; However, we don't use the conversations atom conv state, but keep track of it explicitly in the loop,
      ;; ensuring that we don't have race conditions for conv state. The state kept in the atom is basically
      ;; just a convenience.
      (go-loop [conv conv]
        (log/info &quot;In conversation manager go-loop for zid:&quot; zid)
        (let [first-msg (&lt;! message-chan)
              _ (log/info &quot;Message chan put in queue-message-batch! for zid:&quot; zid)
              msgs (concat [first-msg] (take-all! message-chan))
              {:keys [votes moderation]} (split-batches msgs)
              error-handler (build-update-error-handler conv-man message-chan conv)
              conv (-&gt; conv
                       (pc/?&gt; moderation (conv/mod-update moderation))
                       (pc/?&gt; votes (update-fn votes error-handler)))]
          (log/info &quot;Completed computing conversation zid:&quot; zid)
          (swap! conversations assoc-in [zid :conv] conv)
          (doseq [[k f] @listeners] (try (f conv) (catch Exception e (log/error &quot;Listener error&quot;) (.printStackTrace e))))
          (recur conv))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.darwin.email" name="polismath.darwin.email"><h1 class="project-name">polismath.darwin.email</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.darwin.email
  (:require [polismath.components.env :as env]
            [clj-http.client :as client]))</pre></td></tr><tr><td class="docs"><p>Simple email helper for sending email via mailgun based on config, from, to, subject, text and optionally html</p>
</td><td class="codes"><pre class="brush: clojure">(defn send-email!
  ([config {:keys [from to subject text html] :as params}]
   (let [{:keys [api-key url]} (:email config)]
     (try
       (client/post url
                    {:basic-auth [&quot;api&quot; api-key]
                     :query-params params})
       (catch Exception e (.printStackTrace e)))))
  ([config from to subject text html] (send-email! config {:from from :to to :subject subject :text text :html html}))
  ([config from to subject text] (send-email! config {:from from :to to :subject subject :text text})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.darwin.export" name="polismath.darwin.export"><h1 class="project-name">polismath.darwin.export</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.darwin.export
  (:require [taoensso.timbre.profiling :as profiling
               :refer (pspy pspy* profile defnp p p*)]
            [clojure.java.io :as io]
            [korma.core :as ko]
            [korma.db :as kdb]
            [polismath.components.db :as db]
            ;; Probably should move the function we need out, since this should be meta only XXX
            [polismath.meta.microscope :as micro]
            [polismath.math.clusters :as clust]
            [polismath.math.named-matrix :as nm]
            [polismath.math.conversation :as conv]
            [polismath.utils :as utils]
            [clojure.math.numeric-tower :as math]
            [clojure.core.matrix :as mat]
            [clj-time.core :as t]
            [clj-time.coerce :as co]
            ;; Think I'm going to use the second one here, since it's simpler (less mutable)
            [dk.ative.docjure.spreadsheet :as spreadsheet]
            [clj-excel.core :as excel]
            [semantic-csv.core :as scsv]
            [clojure-csv.core :as csv]
            [clojure.pprint :refer [pprint]]
            [clojure.core.matrix :as mat]
            [clojure.tools.trace :as tr]
            [clojure.tools.logging :as log]
            [clojure.newtools.cli :refer [parse-opts]])
  (:import [java.util.zip ZipOutputStream ZipEntry]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(mat/set-current-implementation :vectorz)</pre></td></tr><tr><td class="docs"><p>Here's rougly what we want for data export. We have the following sheets per conversation.</p>

<p>Summary:
* N Views
* N Voters
* N Voters "in conv"
* N Commenters
* N Groups
* url</p>

<p>Stats History
time, votes, comments, unique-hits, voters, commenters</p>

<p>Votes (full votes matrix):
participant-id, group-id, n-votes, n-comments, n-aggre, n-disagree, <comments...></p>

<p>Comments:
cid, author, aggrees, disagrees, mod, text</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Database calls for various things</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-zids-for-uid
  [uid]
  (map :zid
    (kdb/with-db (db/db-spec)
      (ko/select &quot;conversations&quot;
        (ko/fields :zid)
        (ko/where {:owner uid})))))</pre></td></tr><tr><td class="docs"><p>(get-zids-for-uid 118877)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-zinvite-from-zid
  [zid]
  (-&gt; 
    (kdb/with-db (db/db-spec)
      (ko/select &quot;zinvites&quot;
        (ko/fields :zid :zinvite)
        (ko/where {:zid zid})))
    first
    :zinvite))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-conversation-votes
  ([zid]
   (kdb/with-db (db/db-spec)
     (ko/select db/votes
       (ko/where {:zid zid})
       (ko/order [:zid :tid :pid :created] :asc))))
  ([zid final-vote-timestamp]
   (kdb/with-db (db/db-spec)
     (ko/select db/votes
       (ko/where {:zid zid :created [&lt;= final-vote-timestamp]})
       ; ordering by tid is important, since we rely on this ordering to determine the index within the comps, which needs to correspond to the tid
       (ko/order [:zid :tid :pid :created] :asc)))))</pre></td></tr><tr><td class="docs"><p>Return a map with :topic and :description keys</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-conversation-data
  [zid]
  (-&gt;
    (kdb/with-db (db/db-spec)
      (ko/select &quot;conversations&quot;
        (ko/fields :zid :topic :description :created)
        (ko/where {:zid zid})))
    first))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-participation-data
  ([zid]
   (kdb/with-db (db/db-spec)
     (ko/select &quot;participants&quot;
       (ko/fields :zid :pid :vote_count :created)
       (ko/where {:zid zid}))))
  ([zid final-timestamp]
   (kdb/with-db (db/db-spec)
     (ko/select &quot;participants&quot;
       (ko/fields :zid :pid :vote_count :created)
       (ko/where {:zid zid :created [&lt;= final-timestamp]})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-comments-data
  ([zid]
   (kdb/with-db (db/db-spec)
     (ko/select &quot;comments&quot;
       (ko/fields :zid :tid :pid :txt :mod :created)
       (ko/where {:zid zid}))))
  ([zid final-timestamp]
   (kdb/with-db (db/db-spec)
     (ko/select &quot;comments&quot;
       (ko/fields :zid :tid :pid :txt :mod :created)
       (ko/where {:zid zid :created [&lt;= final-timestamp]})))))</pre></td></tr><tr><td class="docs"><h1>First the summary data</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- count-distinct-col
  ([data]
   (-&gt;&gt; data distinct count))
  ([f data]
   (-&gt;&gt; data (map f) distinct count)))</pre></td></tr><tr><td class="docs"><p>Takes in rating matrix and set of all votes, and computes the summary stats for the
  conversation</p>
</td><td class="codes"><pre class="brush: clojure">(defn summary-data
  [{:keys [n n-cmts group-clusters base-clusters zid rating-mat] :as conv}
   votes
   comments-data
   participants]
  ;; Fire off a bunch of database calls
  (let [zinvite (future (get-zinvite-from-zid zid))
        conv-data (future (get-conversation-data zid))
        ;; Do anything needed with the data to prep
        {:keys [topic description]} @conv-data
        url (str &quot;https://pol.is/&quot; @zinvite)]
    ;; Return the table of stuff to go into excel
    {:topic        topic
     :url          url
     :n-views      (count-distinct-col :pid participants)
     :n-voters     (count-distinct-col :pid votes)
     :n-voters-in  n
     :n-commenters (count-distinct-col :pid comments-data)
     :n-comments   n-cmts
     :n-groups     (count group-clusters)
     :description  description}))</pre></td></tr><tr><td class="docs"><p>Intended for formatting the summary data's psuedo-headers for either excel or csv. Takes the
  data as produced by summary data, and a key-mapping collection of keys as in the data to header
  names to output, returning a collection of rows to be spit out.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-summary-with
  [data key-mapping]
  (for [[k v] key-mapping]
    [v (get data k)]))</pre></td></tr><tr><td class="docs"><h1>Now the history data</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn merge-histories
  [votes participants comments]
  (sort-by :created
           (mapcat
             (fn [collection tag]
               (map #(assoc % :tag tag) collection))
             [votes participants comments]
             [:vote :participant :comment])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti update-history*
  (fn [last-history datom] (:tag datom)))</pre></td></tr><tr><td class="docs"><p>For stats-history; takes the last history value and updates it with the given record. Delegates
  to a multimethod which dispatches on :tag, to determine what values need to be updated, and how.</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-history
  [history datom]
  (conj history
        (-&gt; datom
            (-&gt;&gt; (update-history* (or (last history)
                                   {:n-votes 0 :n-comments 0 :n-visitors 0 :n-voters 0 :n-commenters 0 :ctxt {:voters #{}
                                                                                                            :commenters #{}}})))
            (assoc :time (:created datom)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod update-history* :vote
  [last-history datom]
  (-&gt; last-history
      (update-in [:n-votes] inc)
      (update-in [:n-voters]
                 (fn [n-voters] (if-not (get-in datom [:ctxt :voters (:pid datom)])
                                  (inc n-voters)
                                  n-voters)))
      (update-in [:ctxt :voters] conj (:pid datom))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod update-history* :participant
  [last-history datom]
  (-&gt; last-history
      (update-in [:n-visitors] inc)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod update-history* :comment
  [last-history datom]
  (-&gt; last-history
      (update-in [:n-comments] inc)
      (update-in [:n-commenters]
                 (fn [n-commenters] (if-not (get-in datom [:ctxt :commenters (:pid datom)])
                                      (inc n-commenters)
                                      n-commenters)))
      (update-in [:ctxt :commenters] conj (:pid datom))))</pre></td></tr><tr><td class="docs"><p>Returns rows of {time, n-votes, n-comments, n-visitors, n-voters, n-commenters}</p>
</td><td class="codes"><pre class="brush: clojure">(defn stats-history
  [votes participants comments]
  (reduce update-history [] (merge-histories votes participants comments)))</pre></td></tr><tr><td class="docs"><h1>Full votes matrix (plus some other participant summaries)</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reconstruct-vote-matrix
  [votes]
  (let [new-nmat (nm/named-matrix)
        vote-tuples (map #(map % [:pid :tid :vote]) votes)]
    (nm/update-nmat new-nmat vote-tuples)))</pre></td></tr><tr><td class="docs"><p>Given pred and coll, return the first x in coll for which (pred x) is truthy</p>
</td><td class="codes"><pre class="brush: clojure">(defn ffilter
  [pred coll]
  (first (filter pred coll)))</pre></td></tr><tr><td class="docs"><p>Takes group clusters and base clusters and flattens them out into a cluster mapping to ptpt ids directly</p>
</td><td class="codes"><pre class="brush: clojure">(defn flatten-clusters
  [group-clusters base-clusters]
  (map
    (fn [gc]
      (update-in gc
                 [:members]
                 (fn [members]
                   (mapcat
                     (fn [bid]
                       ;; get the base cluster, then get it's members, mapcat them (a level up)
                       (:members (ffilter #(= (:id %) bid) base-clusters)))
                     members))))
    group-clusters))</pre></td></tr><tr><td class="docs"><p>participant-id, group-id, n-votes, n-comments, n-aggre, n-disagree, <comments...></p>
</td><td class="codes"><pre class="brush: clojure">(defn participants-votes-table
  [conv votes comments]
  (let [mat (reconstruct-vote-matrix votes)
        flattened-clusters (flatten-clusters (:group-clusters conv) (:base-clusters conv))]
    (concat
      ;; The header
      [(into [&quot;participant&quot; &quot;group-id&quot; &quot;n-comments&quot; &quot;n-votes&quot; &quot;n-agree&quot; &quot;n-disagree&quot;] (nm/colnames mat))]
      ;; The rest of the data
      (map
        (fn [ptpt row]
          (into [ptpt
                 (:id (ffilter #(some #{ptpt} (:members %)) flattened-clusters))
                 (count (filter #(= (:pid %) ptpt) comments))
                 (count (remove nil? row))
                 ;; XXX God damn aggree vs disagree...
                 (count (filter #{-1} row))
                 (count (filter #{1} row))]
                row))
        (nm/rownames mat)
        (.matrix mat)))))</pre></td></tr><tr><td class="docs"><p>Apply format-header function to each element of header in a collection of row vectors</p>
</td><td class="codes"><pre class="brush: clojure">(defn format-vote-matrix-header
  [data format-header]
  (concat [(mapv format-header (first data))]
          (rest data)))</pre></td></tr><tr><td class="docs"><h1>Comments</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Just adds vote counts to the comments data</p>
</td><td class="codes"><pre class="brush: clojure">(defn enriched-comments-data
  [comments votes]
  (map
    (fn [{:keys [pid] :as comment-data}]
      (let [comment-votes (filter #(= pid (:pid %)) votes)
            aggrees (filter #(= -1 (:vote %)) comment-votes)
            disagrees (filter #(= 1 (:vote %)) comment-votes)]
        (assoc comment-data :aggrees (count aggrees) :disagrees (count disagrees))))
    comments))</pre></td></tr><tr><td class="docs"><p>Now some reshaping stuff for excel; mostly just applying headers here
Actaul excel things</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stringify-keys
  ([m]
   (stringify-keys m #(-&gt; % str (clojure.string/replace &quot;:&quot; ))))
  ([m f]
   (into {} (map (fn [[k v]]
                   [(if-not (string? k) (f k) k) v])
                 m))))</pre></td></tr><tr><td class="docs"><p>Little utility for generating a function that either updates based on a map (closed over) or leaves value unchanged</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-from-map-or-leave
  [m]
  (fn [k]
    (if-let [v (get m k)]
      v
      k)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn excel-format
  [export-data]
  (-&gt; export-data
      (update-in [:summary]
                 render-summary-with
                 [[:topic        &quot;Topic&quot;]
                  [:url          &quot;URL&quot;]
                  [:n-views      &quot;Views&quot;]
                  [:n-voters     &quot;Voters&quot;]
                  [:n-voters-in  &quot;Voters (in conv)&quot;]
                  [:n-commenters &quot;Commenters&quot;]
                  [:n-comments   &quot;Comments&quot;]
                  [:n-groups     &quot;Groups&quot;]
                  [:description  &quot;Conversation Description&quot;]])
      (update-in [:stats-history]
                 (partial scsv/vectorize {:header [:n-votes :n-comments :n-visitors :n-voters :n-commenters]
                                          :format-header {:n-votes      &quot;Votes&quot;
                                                          :n-visitors   &quot;Visitors&quot;
                                                          :n-voters     &quot;Voters&quot;
                                                          :n-comments   &quot;Comments&quot;
                                                          :n-commenters &quot;Commenters&quot;}}))
      (update-in [:comments]
                 (partial scsv/vectorize {:header [:tid :pid :aggrees :disagrees :mod :txt]
                                          :format-header {:tid       &quot;Comment ID&quot;
                                                          :pid       &quot;Author&quot;
                                                          :aggrees   &quot;Aggrees&quot;
                                                          :disagrees &quot;Disagrees&quot;
                                                          :mod       &quot;Moderated&quot;
                                                          :txt       &quot;Comment body&quot;}}))
      (update-in [:participants-votes]
                 format-vote-matrix-header
                 ;; flesh out...
                 (update-from-map-or-leave {&quot;participant&quot; &quot;Participant&quot;
                                            &quot;group-id&quot;    &quot;Group ID&quot;
                                            &quot;n-comments&quot;  &quot;Comments&quot;
                                            &quot;n-votes&quot;     &quot;Votes&quot;
                                            &quot;n-agree&quot;     &quot;Agrees&quot;
                                            &quot;n-disagree&quot;  &quot;Disagrees&quot;}))
      (stringify-keys (array-map :summary &quot;Summary&quot;
                                 :stats-history &quot;Stats History&quot;
                                 :comments &quot;Comments&quot;
                                 :participants-votes &quot;Participants Votes&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn csv-format
  [export-data]
  (-&gt; export-data
      (update-in [:summary]
                 render-summary-with
                 [[:topic        &quot;topic&quot;]
                  [:url          &quot;url&quot;]
                  [:n-views      &quot;views&quot;]
                  [:n-voters     &quot;voters&quot;]
                  [:n-voters-in  &quot;voters-in-conv&quot;]
                  [:n-commenters &quot;commenters&quot;]
                  [:n-comments   &quot;comments&quot;]
                  [:n-groups     &quot;groups&quot;]
                  [:description  &quot;conversation-description&quot;]])
      (update-in [:stats-history]
                 (partial scsv/vectorize {:header [:n-votes :n-comments :n-visitors :n-voters :n-commenters]}))
      (update-in [:comments]
                 (partial scsv/vectorize {:header [:tid :pid :aggrees :disagrees :mod :txt]
                                          :format-header {:tid       &quot;comment-id&quot;
                                                          :pid       &quot;author-id&quot;
                                                          :aggrees   &quot;agrees&quot;
                                                          :disagrees &quot;disagrees&quot;
                                                          :mod       &quot;moderated&quot;
                                                          :txt       &quot;comment-body&quot;}}))))</pre></td></tr><tr><td class="docs"><p>This zip nonsense is stolen from http://stackoverflow.com/questions/17965763/zip-a-file-in-clojure</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:private with-entry
  [zip entry-name &amp; body]
  `(let [^ZipOutputStream zip# ~zip]
     (.putNextEntry zip# (ZipEntry. ~entry-name))
     ~@body
     (flush)
     (.closeEntry zip#)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn move-to-zip-stream
  [zip-stream input-filename entry-point]
  (with-open [input  (io/input-stream input-filename)]
    (with-entry zip-stream entry-point
      (io/copy input zip-stream))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-csv
  [table]
  (-&gt;&gt; table
       (map (partial mapv str))
       csv/write-csv
       print))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn zipfile-basename
  [filename]
  (-&gt; filename 
      (clojure.string/split #&quot;\/&quot;)
      last
      (clojure.string/replace #&quot;\.zip$&quot; )))</pre></td></tr><tr><td class="docs"><p>Must assert .zip in filenames or things will break on unzipping XXX</p>
</td><td class="codes"><pre class="brush: clojure">(defn save-to-csv-zip
  ([filename data]
   (with-open [file (io/output-stream filename)
               zip  (ZipOutputStream. file)]
     (save-to-csv-zip zip (zipfile-basename filename) data)))
  ([zip-stream entry-point-base data]
   (with-open [wrt  (io/writer zip-stream)]
     (binding [*out* wrt]
       (doto zip-stream
         (with-entry (str entry-point-base &quot;/summary.csv&quot;)
           (print-csv (:summary data)))
         (with-entry (str entry-point-base &quot;/stats-history.csv&quot;)
           (print-csv (:stats-history data)))
         (with-entry (str entry-point-base &quot;/comments.csv&quot;)
           (print-csv (:comments data)))
         (with-entry (str entry-point-base &quot;/participants-votes.csv&quot;)
           (print-csv (:participants-votes data))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save-to-excel
  ([filename data]
   (-&gt; (excel/build-workbook data)
       (excel/save filename)))
  ;; Should really change both this and the above to use the .zip filename, and take basename for the main dir
  ;; XXX
  ([zip-stream entry-point data]
   ;; Would be nice if we could write directly to the zip stream, but the excel library seems to be doing
   ;; weird things...
   (let [tmp-file-path (str &quot;tmp/rand-&quot; (rand-int Integer/MAX_VALUE) &quot;.xml&quot;)]
     (save-to-excel tmp-file-path data)
     (move-to-zip-stream zip-stream tmp-file-path entry-point))))</pre></td></tr><tr><td class="docs"><h1>Putting it all together</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-export-data
  [{:keys [zid zinvite env-overrides] :as kw-args}]
  (let [zid (or zid (micro/get-zid-from-zinvite zinvite))
        ;; assert zid
        votes (get-conversation-votes zid)
        comments (enriched-comments-data (get-comments-data zid) votes)
        participants (get-participation-data zid)
        ;; Should factor out into separate function
        conv (utils/apply-kwargs micro/load-conv kw-args)]
    {:summary (summary-data conv votes comments participants)
     :stats-history (stats-history votes participants comments)
     :participants-votes (participants-votes-table conv votes comments)
     :comments comments}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-export-data-at-date
  [{:keys [zid zinvite env-overrides at-date] :as kw-args}]
  (let [zid (or zid (micro/get-zid-from-zinvite zinvite))
        votes (get-conversation-votes zid at-date)
        conv (assoc (conv/new-conv) :zid zid)
        conv (conv/conv-update conv votes)
        _ (println &quot;Done with conv update&quot;)
        comments (enriched-comments-data (get-comments-data zid at-date) votes)
        participants (get-participation-data zid at-date)
        ]
    {:summary (assoc (summary-data conv votes comments participants) :at-date at-date)
     :stats-history (stats-history votes participants comments)
     :participants-votes (participants-votes-table conv votes comments)
     :comments comments}))</pre></td></tr><tr><td class="docs"><p>This is the main API endpoint for the export functionality. Given either :zid or :zinvite, export data to
  the specified :format and spit results out to :filename. Optionally, a :zip-stream and :entry point may be
  specified, which can be used for biulding up items in a zip file. This is used in export/-main to export all
  convs for a given uid, for example.</p>
</td><td class="codes"><pre class="brush: clojure">(defn export-conversation
  ;; Don't forget env-overrides {:math-env &quot;prod&quot;}; should clean up with system
  [{:keys [zid zinvite format filename zip-stream entry-point env-overrides at-date] :as kw-args}]
  (log/info &quot;Exporting data for zid =&quot; zid &quot;, zinvite =&quot; zinvite)
  (let [export-data (if at-date 
                      (get-export-data-at-date kw-args)
                      (get-export-data kw-args))
        [formatter saver] (case format :excel [excel-format save-to-excel] :csv [csv-format save-to-csv-zip])
        formatted (formatter export-data)]
    (if zip-stream
      (if (-&gt; export-data :summary :n-voters (&gt; 0))
        (saver zip-stream entry-point formatted)
        (println &quot;Skipping conv&quot; zid zinvite &quot;, since no votes&quot;))
      (saver filename formatted))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-date
  [s]
  (-&gt;&gt; (clojure.string/split s #&quot;\s+&quot;)
       (map #(Integer/parseInt %))
       (apply t/date-time)
       co/to-long))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def cli-options
  [[&quot;-z&quot; &quot;--zid ZID&quot;           &quot;ZID on which to do a rerun&quot; :parse-fn #(Integer/parseInt %)]
   [&quot;-Z&quot; &quot;--zinvite ZINVITE&quot;   &quot;ZINVITE code on which to perform a rerun&quot;]
   [&quot;-u&quot; &quot;--user-id USER_ID&quot;   &quot;Export all conversations associated with ZID, and place in zip file&quot; :parse-fn #(Integer/parseInt %)]
   [&quot;-a&quot; &quot;--at-date AT_DATE&quot;   &quot;A string of YYYY MM DD HH MM SS (in UTC)&quot; :parse-fn parse-date]
   [&quot;-f&quot; &quot;--format FORMAT&quot;     &quot;Either csv, excel or (soon) json&quot; :parse-fn keyword :validate [#{:csv :excel} &quot;Must be either csv or excel&quot;]]
   ;; -U ;utc offset?
   [&quot;-h&quot; &quot;--help&quot;              &quot;Print help and exit&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn error-msg [errors]
  (str &quot;The following errors occurred while parsing your command:\n\n&quot;
       (clojure.string/join \newline errors)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn help-msg [options]
  (str &quot;Export a conversation or set of conversations according to the options below:\n\n&quot;
       \tab
       &quot;filename&quot; \tab &quot;Filename (or file basename, in case of zip output, implicit or explicit&quot; \newline
       (clojure.string/join \newline
                            (for [opt cli-options]
                              (apply str (interleave (repeat \tab) (take 3 opt)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn exit [status msg]
  (println msg)
  (System/exit status))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -main
  [&amp; args]
  (let [{:keys [options arguments errors summary]} (parse-opts args cli-options)]
    (println options arguments)
    (cond
      (:help options) (exit 0 (help-msg cli-options))
      errors          (exit 1 (error-msg errors)))
    (let [filename (first arguments)
          options (assoc options :env-overrides {:math-env &quot;prod&quot;} :filename filename)]
      (if-let [uid (:user-id options)]
        ;; maybe here check if filename ends in zip and add if not; safest, and easiest... XXX
        (with-open [file (io/output-stream filename)
                    zip  (ZipOutputStream. file)]
          (doseq [zid (get-zids-for-uid uid)]
            (let [zinvite (get-zinvite-from-zid zid)
                  ext (case (:format options) :excel &quot;xls&quot; :csv &quot;csv&quot;)]
              (println &quot;Now working on conv:&quot; zid zinvite)
              (export-conversation (assoc options
                                          :zid zid
                                          :zip-stream zip
                                          :entry-point (str (zipfile-basename filename) &quot;/&quot; zinvite &quot;.&quot; ext))))))
        (export-conversation options))
      (exit 0 &quot;Export complete&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.darwin.server" name="polismath.darwin.server"><h1 class="project-name">polismath.darwin.server</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.darwin.server
  (:require [polismath.darwin.export :as export]
            ;; XXX Deprecate; use component config directly
            [polismath.components.env :as env]
            [polismath.components.db :as db]
            [polismath.darwin.email :as email]
            [clojure.core.async :as async :refer [chan &gt;!! &lt;!! &gt;! &lt;! go]]
            [clojure.tools.logging :as log]
            [ring.component.jetty :refer [jetty-server]]
            [ring.util.response :as response]
            [ring.middleware.params :as ring.params]
            [ring.middleware.ssl :as ssl]
            [ring.middleware.keyword-params :as ring.keyword-params]
            [ring.middleware.basic-authentication :as auth :refer [wrap-basic-authentication]]
            [bidi.bidi :as bidi]
            [com.stuartsierra.component :as component]
            [monger.collection :as mc]
            [hiccup.core :as hiccup]
            [amazonica.aws.s3 :as s3]
            [clj-time.core :as time]))</pre></td></tr><tr><td class="docs"><p>First we'll just set up some basic helpers and settings/variables we'll need.
We'll really want to move these to the configuration component when that exists. XXX</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def tmp-dir (or (:export-temp-dir env/env) &quot;/tmp/&quot;)) ; XXX</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn full-path [filename] (str tmp-dir filename))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def app-url-base (or (:export-server-url-base env/env) &quot;http://localhost:3000&quot;))
(defn full-url
  [&amp; path]
  (apply str app-url-base &quot;/&quot; path))</pre></td></tr><tr><td class="docs"><p>A ping handler will just be for debugging purposes</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Simple ping handler. Returns response with edn representation of the request as the body.
  For testing purposes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ping-handler
  [request]
  {:status  200
   :headers {&quot;Content-Type&quot; &quot;text/plain&quot;}
   :body (with-out-str (clojure.pprint/pprint request))})</pre></td></tr><tr><td class="docs"><p>The filename is actually pretty iportant.
It should be unique between different expors, as is used as the identifying key for the aws buckets, mongo
tracking and as part of the API requests.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Generates a filename based on request-params</p>
</td><td class="codes"><pre class="brush: clojure">(defn generate-filename
  [{:keys [zinvite at-date format] :as request-params}]
  (let [last-updated (or at-date (System/currentTimeMillis))
        ext (case format :excel &quot;xlsx&quot; :csv &quot;zip&quot;)
        filename (str &quot;polis-export-&quot; zinvite &quot;-&quot; last-updated &quot;.&quot; ext)]
    filename))</pre></td></tr><tr><td class="docs"><p>The following is really just a bunch of parameter parsing stuff.
Tihs could all possibly be interwoven with the config component as well.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Try to parse as an integer; return nil if not possible.</p>
</td><td class="codes"><pre class="brush: clojure">(defn -&gt;double
  [x]
  (try (Double/parseDouble x)
       (catch Exception e nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def parsers {:at-date -&gt;double :format keyword})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def allowed-params #{:filename :zinvite :at-date :format :email})</pre></td></tr><tr><td class="docs"><p>Parses the params for a request, occording to parsers.</p>
</td><td class="codes"><pre class="brush: clojure">(defn parsed-params
  [params]
  ;(log/info &quot;Here are the params:&quot; params)
  (reduce
    (fn [m [k v]]
      ;; Don't really need this if we have params instead of query params, but whateves
      (let [k (keyword k)]
        (if (allowed-params k)
                      (assoc m k ((or (parsers k) identity) v))
                      m)))
    {}
    params))</pre></td></tr><tr><td class="docs"><p>We use mongo to persists the status of our exports, and data needed for downloading from AWS.
Here, we're setting up basic mongo read and write helpers.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update-export-status
  [filename zinvite document]
  (mc/update (db/mongo-db (:mongolab-uri env/env))
             (db/mongo-collection-name &quot;exports&quot;)
             {:filename filename :zinvite zinvite}
             (db/format-for-mongo identity (assoc document
                                                  :filename filename
                                                  :zinvite zinvite
                                                  :lastupdate (System/currentTimeMillis)))
             {:upsert true}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-export-status
  [filename zinvite]
  (mc/find-one (db/mongo-db (:mongolab-uri env/env))
               (db/mongo-collection-name &quot;exports&quot;)
               {:filename filename :zinvite zinvite}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn notify-mongo
  [filename status params]
  (update-export-status filename (:zinvite params) {:status status :params params}))</pre></td></tr><tr><td class="docs"><p>We use AWS to store conversation exports whcih took a long time to compute.
These exports are set to expire automatically.
The number of days before expiry should be stored in env variable :export-expiry-days.
This value is used to compute the expiry of the exports mongo collection as well.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>move to component; uncomment on commit XXX</p>
</td><td class="codes"><pre class="brush: clojure">(def aws-cred {:access-key (env/env :aws-access-key)
               :secret-key (env/env :aws-secret-key)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn full-aws-path
  [filename]
  (str (:math-env env/env) &quot;/&quot; filename))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn upload-to-aws
  [aws-cred filename]
  (s3/put-object aws-cred
                 :bucket-name &quot;polis-datadump&quot;
                 :key (full-aws-path filename)
                 :file (full-path filename)))</pre></td></tr><tr><td class="docs"><p>This will end up redirecting to the aws download link</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-datadump-url
  [filename zinvite]
  (full-url (str &quot;datadump/results?filename=&quot; filename &quot;&amp;zinvite=&quot; zinvite)))</pre></td></tr><tr><td class="docs"><p>Email notification of completion</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn hiccup-to-plain-text-dispatch
  [hiccup-or-string]
  (if (string? hiccup-or-string)
    :type/string
    (first hiccup-or-string)))</pre></td></tr><tr><td class="docs"><p>Converts hiccup data to plain text.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti hiccup-to-plain-text
  {:arglists '([hiccup])}
  hiccup-to-plain-text-dispatch)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod hiccup-to-plain-text :default
  [[tag &amp; args]]
  (let [args (if (map? (first args)) (rest args) args)]
    (clojure.string/join &quot;&quot; (map hiccup-to-plain-text args))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod hiccup-to-plain-text :type/string
  ;; This one is a little hacky... should probaby do this a different way
  [string]
  string)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod hiccup-to-plain-text :p
  [[tag &amp; args]]
  (let [args (if (map? (first args)) (rest args) args)]
    (str (clojure.string/join &quot;&quot; (map hiccup-to-plain-text args)) &quot;\n\n&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod hiccup-to-plain-text :a
  ;; Should add metadata about what should happen with :a (href or innner)
  [[tag attrs &amp; args]]
  (:href attrs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod hiccup-to-plain-text :br
  [tag &amp; args]
  &quot;\n&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn completion-email-text
  [zinvite download-url]
  (let [conv-url (str &quot;pol.is/&quot; zinvite)
        polis-link [:a {:href &quot;pol.is&quot;} &quot;pol.is&quot;]]
    [:html
     [:p &quot;Greetings&quot;]
     [:p &quot;You created a data export for &quot; polis-link
         &quot; conversation &quot; [:a {:href conv-url} conv-url] &quot; that has just completed. &quot;
         &quot;You can download the results for this conversation at the following url:&quot;]
     [:p [:a {:href download-url} download-url]]
     [:p &quot;Please let us know if you have any questons about the data.&quot;]
     [:p &quot;Thanks for using &quot; polis-link &quot;!&quot;]
     [:p &quot;Christopher Small&quot; [:br] &quot;Chief Data Scientist&quot;]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn send-email-notification!
  [filename params]
  (let [zinvite (:zinvite params)
        download-url (get-datadump-url filename zinvite)
        email-hiccup (completion-email-text zinvite download-url)]
    (email/send-email!
      &quot;Christopher Small &lt;chris@pol.is&gt;&quot;
      (:email params)
      (str &quot;Data export for pol.is conversation pol.is/&quot; zinvite)
      (hiccup-to-plain-text email-hiccup)
      (hiccup/html email-hiccup))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn handle-completion!
  [aws-cred filename params]
  (log/info &quot;Completed export computation for filename&quot; filename &quot;params:&quot; (with-out-str (str params)))
  (upload-to-aws aws-cred filename)
  (notify-mongo filename &quot;complete&quot; params)
  (when (:email params) (send-email-notification! filename params)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn handle-timedout-datadump!
  [aws-cred filename compute-chan params]
  (log/info &quot;Timed out on datadump computation for filename&quot; filename &quot;params:&quot; (with-out-str (str params)) &quot;. Starting async lifecycle.&quot;)
  ;; First let mongo know we're working on it
  (notify-mongo filename &quot;processing&quot; params)
  ;; Start a go routine, which upon completion of the computation loads the data to
  ;; aws and updates the mongo
  (go (when-let [late-result (&lt;! compute-chan)]
        (handle-completion! aws-cred filename params))))</pre></td></tr><tr><td class="docs"><p>Generate a presigned url from amazon for the given filename. Optionally set an expiration in hours (defaulting to the number
  sourced from env variable :download-link-expiration-hours.</p>
</td><td class="codes"><pre class="brush: clojure">(defn generate-aws-url!
  ([aws-cred filename expiration]
   ;; XXX more env/env stuff
   (let [expiration (-&gt; expiration time/hours time/from-now)]
     (str (s3/generate-presigned-url aws-cred &quot;polis-datadump&quot; (full-aws-path filename) expiration))))
  ([aws-cred filename]
   (let [expiration (-&gt;double (:export-aws-link-expiration-hours env/env))]
     (generate-aws-url! aws-cred filename expiration))))</pre></td></tr><tr><td class="docs"><p>(let [filename "polis-export-6sc6vt-1445837850044.zip"]
(str (s3/generate-presigned-url aws-cred "polis-datadump" (full-aws-path filename) 3)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>What follows is the guts of our responding and computing.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>We try to respond as soon as possible to the request.
If the computation takes too long, we respond with a 202 and a Location pointing to a status url.
When that url is pinged, it responds a 200 saying to check back later if it's not done.
If the computation is complete, it responds with a 201, and a url at which the results can be downloaded.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A more detailed outline of what this looks like in code is as follows:</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>get export params
  * notify-mongo (:started)
  * start computing
  * complete:
      * go:
           * upload-aws
           * notify-mongo (:complete)
      * response 200
  * timeout
      * notify-mongo (:processing)
      * response 202
      * go:
           * complete:
                * upload-aws
                * notify-mongo (:complete)
get export filename
  * not ready
      * 404 not there
  * ready
      * proxy aws file
get status filename
  * check status
  * done:
      * respond 201
      * link for download
  * pending
      * send link for download.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>General helpers..</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def respond-404
  {:status 404
   :headers {&quot;Content-Type&quot; &quot;text/plain&quot;}
   :body &quot;Unknown, incomplete or expired conversation export&quot;})</pre></td></tr><tr><td class="docs"><p>Requests for exported files in aws.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Creates a redirection response, which redirects to the aws download link.</p>
</td><td class="codes"><pre class="brush: clojure">(defn redirect-to-aws-url
  [aws-cred filename]
  (response/redirect
    (generate-aws-url! aws-cred filename)))</pre></td></tr><tr><td class="docs"><p>Given aws-creds, returns a function handler function which responds to requests for an existing file on AWS.</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-filename-request-handler
  [aws-cred]
  (fn [{:keys [params] :as request}]
    (let [{:keys [filename zinvite]} params]
      (if (= (get (get-export-status filename zinvite) &quot;status&quot;) &quot;complete&quot;)
        ;; Have to think about the security repercussions here. Would be nice if we could stream this and never
        ;; expose the link here. XXX
        (redirect-to-aws-url aws-cred filename)
        respond-404))))</pre></td></tr><tr><td class="docs"><p>Couple helpful things for below</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-status-location-url
  [filename zinvite]
  (full-url (str &quot;datadump/status?filename=&quot; filename &quot;&amp;zinvite=&quot; zinvite)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn check-back-response
  ([filename zinvite status]
   (let [status-url (get-status-location-url filename zinvite)]
     {:status  status
      :headers {&quot;Content-Type&quot; &quot;text/plain&quot;
                &quot;Location&quot; status-url}
      :body    (str &quot;Request is processing, but cannot be returned now. &quot;
                    &quot;Please visit the url in the \&quot;Location\&quot; header (&quot; status-url &quot;) to check back on the status.&quot;)}))
  ([filename zinvite] (check-back-response filename zinvite 202)))</pre></td></tr><tr><td class="docs"><p>Requests for checking the status of a computation</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn complete-response
  [filename zinvite]
  (let [url (get-datadump-url filename zinvite)]
    {:status  201
     :headers {&quot;Content-Type&quot; &quot;text/plain&quot;
               &quot;Location&quot;     url}
     :body    (str &quot;Export is complete. Download at the Location url specified in the header (&quot; url &quot;)&quot;)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-datadump-status-handler
  [{:keys [params] :as request}]
  (let [{:keys [filename zinvite]} params]
    (case (-&gt; (get-export-status filename zinvite) (get &quot;status&quot;))
      (&quot;pending&quot; &quot;started&quot; &quot;processing&quot;) (check-back-response filename zinvite 200)
      &quot;complete&quot;                         (complete-response filename zinvite)
      ;; In case we don't match, 404
      respond-404)))</pre></td></tr><tr><td class="docs"><p>Top level; either run and return the computation results, or set things up for a 202-lifecycle to be
completed down the road.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Based on params this actually runs the export-conversation computation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn run-datadump
  [filename params]
  (log/info &quot;Params for run-datadump are:&quot; (with-out-str (prn params)))
  (try
    (let [;; The dissoc is just a vague security measure
          request-params (-&gt; params
                             (dissoc :env-overrides)
                             (assoc :filename (full-path filename)))]
      (export/export-conversation request-params)
      ;; Return truthy :done token
      :done)
    (catch Exception e
      (log/error &quot;Error with datadump computation:&quot; (with-out-str (prn params)))
      (.printStackTrace e)
      {:exception e})))</pre></td></tr><tr><td class="docs"><p>Main handler function; Attempts to return a datadump file within within a set amount of time, and if it can't, will
  respond with a 202, and set up a process for obtaining the results once they're done.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-datadump-handler
  [{:keys [params] :as request}]
  (let [params (parsed-params params)
        ;; Check validity of params here
        _ (log/info &quot;Handling datadump request with params:&quot; (with-out-str (prn params)))
        filename (generate-filename params)
        datadump (async/thread (run-datadump filename params))
        timeout (async/timeout 100000)
        [done? _] (async/alts!! [datadump timeout])]
    (cond
      ;; We'll try to catch all exceptions before this 
      (:exception done?) 
      {:status 500 :headers {&quot;Content-Type&quot; &quot;text/plain&quot;} :body &quot;There was an error processing this request.&quot;}
      ;; Any other truthy value means we have successful computation
      done?
      (do
        (handle-completion! aws-cred filename params)
        (assoc-in (response/file-response (full-path filename))
                   [:headers &quot;Content-Disposition&quot;]
                   (str &quot;attachment; filename=&quot; \&quot; filename \&quot;)))
      ;; Otherwise, the timeout hit, and we should trigger the check back later lifecycle
      :else
      (do
        (handle-timedout-datadump! aws-cred filename datadump params)
        (check-back-response filename (:zinvite params))))))</pre></td></tr><tr><td class="docs"><p>Route everything together, build handlers, etc</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def routes
  [&quot;/&quot; {&quot;ping&quot;      ping-handler
        &quot;datadump/&quot; {&quot;get&quot;     get-datadump-handler
                     &quot;status&quot;  get-datadump-status-handler
                     &quot;results&quot; (make-filename-request-handler aws-cred)}}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def handler
  (bidi.ring/make-handler routes))</pre></td></tr><tr><td class="docs"><p>securitay ;; move env variables to config component</p>
</td><td class="codes"><pre class="brush: clojure">(defn authenticated? [name pass]
  (and (= name (:export-server-auth-username env/env))
       (= pass (:export-server-auth-pass env/env))))</pre></td></tr><tr><td class="docs"><p>Again, base on config component  XXX</p>
</td><td class="codes"><pre class="brush: clojure">(defn redirect-http-to-https-if-required
  [handler]
  ;; Can cast this as bool? XXX
  ;(if (= (:export-server-require-ssl env/env) &quot;true&quot;)
  (if false
    (do
      ;; Should be using log
      (log/info &quot;SERVER_REQUIRE_SSL set to true; using redirect middleware.&quot;)
      (-&gt; handler ssl/wrap-forwarded-scheme ssl/wrap-ssl-redirect))
    (do
      (log/info &quot;SERVER_REQUIRE_SSL unset; ssl not being required.&quot;)
      handler)))</pre></td></tr><tr><td class="docs"><p>config env var?</p>
</td><td class="codes"><pre class="brush: clojure">(def valid-remote-addresses #{&quot;pol.is&quot; &quot;preprod.pol.is&quot; &quot;127.0.0.1&quot; &quot;polis.herokuapp.com&quot; &quot;polis-preprod.herokuapp.com&quot;})
(defn restrict-remote-address
  [handler]
  (fn [request]
    (if-not (valid-remote-addresses (:remote-addr request))
      {:status 401 :header {&quot;Content-Type&quot; &quot;text/plain&quot;} :body &quot;Domain restriction is activated, and you are not requesting from an authorized domain&quot;}
      (handler request))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def app
  {:handler
   (-&gt; handler
       ring.keyword-params/wrap-keyword-params
       ring.params/wrap-params
       (auth/wrap-basic-authentication authenticated?)
       ;redirect-http-to-https-if-required
       ;restrict-remote-access)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-port
  [default]
  (or (try
        ;; Component XXX
        (Double/parseDouble (:port env/env))
        (catch Exception e default))))</pre></td></tr><tr><td class="docs"><p>Enter component:
This is a bit of a hack right now, since the rest of our system is not in components... But whatevs. XXX
In short we're creating a reference to hold our server, and setting up functions for starting, stopping and
reloading that reference.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *jetty-settings*
  {:app app
   :port (get-port 3000)
   ;; Not sure exactly what this is doing; maybe leave out XXX
   :client-auth :need
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce http-server
  (jetty-server *jetty-settings*))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start-server!
  []
  (alter-var-root #'http-server component/start))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stop-server!
  []
  (alter-var-root #'http-server component/stop))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reset-server!
  []
  (stop-server!)
  (def http-server (jetty-server *jetty-settings*))
  (start-server!))</pre></td></tr><tr><td class="docs"><p>Main function; just start the component</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -main []
  (start-server!))</pre></td></tr><tr><td class="docs"><p>TODO / Thoughts</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h1>Implement</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Set up env variables in server: :export-aws-link-expiration, :export-expiry-days, :server-port,
:export-server-auth-username, :export-server-auth-pass, :aws-access-key, :aws-secret-key</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Error handling on export fail...</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Should do validations on request params and return 4xx if anything is fishy</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h1>Check</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>auth middleware [x]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Require zinvite from server request for downloaded conv, so that it's easier to secure (test)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>ssl redirects and such</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h1>Ideas</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>See if it's possible to proxy/mask the aws signed url instead of redirect</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Mmm... how to delete pending submissions that get canceled due to a server restart? maybe we keep track of
a global of what processing are running and for which exports, and look at that when we get a status
request</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Auto retry conversations that somehow fail based on heart beat?</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.email" name="polismath.email"><h1 class="project-name">polismath.email</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.email
  (:require [polismath.env :as env]
            [clj-http.client :as client]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *mailgun-key* (:mailgun-api-key env/env))
(def ^:dynamic *mailgun-url* (:mailgun-url env/env))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn send-email!
  ([{:keys [from to subject text html] :as params}]
   (try
     (client/post *mailgun-url*
                  {:basic-auth [&quot;api&quot; *mailgun-key*]
                   :query-params params})
     (catch Exception e (.printStackTrace e))))
  ([from to subject text html] (send-email! {:from from :to to :subject subject :text text :html html}))
  ([from to subject text] (send-email! {:from from :to to :subject subject :text text})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.math.clusters" name="polismath.math.clusters"><h1 class="project-name">polismath.math.clusters</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.math.clusters
  (:refer-clojure :exclude [* - + == /])
  (:require [taoensso.timbre.profiling :as profiling
             :refer (pspy pspy* profile defnp p p*)]
            [plumbing.core :as pc
             :refer (fnk map-vals &lt;-)]
            [plumbing.graph :as gr]
            [clojure.tools.trace :as tr]
            ; [alex-and-georges.debug-repl :as dbr]
            [polismath.utils :as utils]
            [polismath.math.stats :as stats]
            [polismath.math.named-matrix :as nm]
            [clojure.core.matrix :as matrix]
            [clojure.core.matrix.stats :as matrix-stats]
            [clojure.core.matrix.operators :refer :all]
            [clojure.core.matrix.select :as matrix-select]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(matrix/set-current-implementation :vectorz)</pre></td></tr><tr><td class="docs"><p>Append an item to a cluster, where item is a (mem_id, vector) pair</p>
</td><td class="codes"><pre class="brush: clojure">(defn clst-append
  [clst item]
  (assoc clst
         ; Note that order is important here, and assumed to be the same for the weighted-mean call in
         ; `cluster-step`.
         :members (conj (:members clst) (first item))
         :positions (conj (:positions clst) (last item))))</pre></td></tr><tr><td class="docs"><p>Find the closest cluster and append item (mem_id, vector) to it</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-to-closest
  [clusts item]
  (let [[clst-id clst] (apply min-key
                         (fn [[clst-id clst]]
                           (matrix/distance (last item) (:center clst)))
                         clusts)]
    (assoc clusts clst-id
      (clst-append clst item))))</pre></td></tr><tr><td class="docs"><p>Effectively random initial clusters for initializing a new kmeans comp</p>
</td><td class="codes"><pre class="brush: clojure">(defn init-clusters
  [data k]
  (take k
    (map-indexed
      (fn [id position] {:id id :members [] :center (matrix/matrix position)})
      ; Have to make sure we don't have identical cluster centers
      (distinct (matrix/rows (nm/get-matrix data))))))</pre></td></tr><tr><td class="docs"><p>Determines whether clusterings are within tolerance by measuring distances between
  centers. Note that cluster centers here must be vectors and not NDArrays</p>
</td><td class="codes"><pre class="brush: clojure">(defn same-clustering?
  [clsts1 clsts2 &amp; {:keys [threshold] :or {threshold 0.01}}]
  (letfn [(cntrs [clsts] (sort (map :center clsts)))]
    (every?
      (fn [[x y]]
        (&lt; (matrix/distance x y) threshold))
      (utils/zip (cntrs clsts1) (cntrs clsts2)))))</pre></td></tr><tr><td class="docs"><p>Clears a cluster's members so that new ones can be assoced on a new clustering step</p>
</td><td class="codes"><pre class="brush: clojure">(defn cleared-clusters
  [clusters]
  (into {} (map #(vector (:id %) (assoc % :members [] :positions [])) clusters)))</pre></td></tr><tr><td class="docs"><p>Compute either the mean or weighted mean (if :weights is passed) of either a matrix or
  named matrix. For a matrix, :weights should be vector, the ith element of which is the
  weight corresponding to row i of mat. For a named matrix, it should be a hash.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti weighted-mean
  (fn [&amp; args]
    [(matrix/matrix? (first args))
     (matrix/vec? (first args))]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod weighted-mean [true false]
  [mat &amp; {:keys [weights]}]
  (if weights
    (weighted-mean
      (* (/ (count weights) (pc/sum weights))
         (reduce
           (fn [m [row-i weight]]
             (matrix/multiply-row m row-i weight))
           mat
           (utils/with-indices weights))))
    (matrix-stats/mean (matrix/matrix mat))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod weighted-mean [false true]
  [v &amp; {:keys [weights]}]
  (if weights
    (/ (matrix/dot weights v) (pc/sum weights))
    (matrix-stats/mean v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod weighted-mean [false false]
  [nmat &amp; {:keys [weights]}]
  (weighted-mean (nm/get-matrix nmat)
                 :weights
                 (when weights
                   (reduce
                     #(conj %1 (weights %2))
                     []
                     (nm/rownames nmat)))))</pre></td></tr><tr><td class="docs"><p>Get a weights seq given a cluster with :members and a hash-map of weights. Returns nil
  if hm-weights is falsey.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cluster-weights
  [cluster hm-weights]
  (when hm-weights
    (-&gt;&gt; (:members cluster)
         (map hm-weights))))</pre></td></tr><tr><td class="docs"><p>Performs one step of an iterative K-means:
  data-iter: seq of pairs (id, position), eg (pid, person-rating-row)
  clusters: array of clusters</p>
</td><td class="codes"><pre class="brush: clojure">(defn cluster-step
  [data-iter k clusters &amp; {:keys [weights]}]
  (-&gt;&gt; data-iter
    ; Reduces a &quot;blank&quot; set of clusters w/ centers into clusters that have elements
    (reduce add-to-closest (cleared-clusters clusters))
    vals
    ; Filter out clusters that don't have any members (should maybe log on verbose?)
    (filter #(&gt; (count (:members %)) 0))
    ; Apply mean to get updated centers
    (map (fn [clst]
           (-&gt; clst
               (assoc :center (weighted-mean (:positions clst)
                                             :weights (cluster-weights clst weights)))
               (dissoc :positions))))))</pre></td></tr><tr><td class="docs"><p>Replace cluster centers with a center computed from new positions</p>
</td><td class="codes"><pre class="brush: clojure">(defn recenter-clusters
  [data clusters &amp; {:keys [weights]}]
  (map
    (fn [clst]
      (assoc clst :center (weighted-mean (nm/rowname-subset data (:members clst))
                                         :weights weights)))
    clusters))</pre></td></tr><tr><td class="docs"><p>Replace cluster centers with a center computed from new positions</p>
</td><td class="codes"><pre class="brush: clojure">(defn safe-recenter-clusters
  [data clusters &amp; {:keys [weights]}]
  (as-&gt; clusters clsts
    ; map every cluster to the newly centered cluster or to nil if there are no members in data
    (map
      (fn [clst]
        (let [rns (nm/safe-rowname-subset data (:members clst))]
          (if (empty? (nm/rownames rns))
            nil
            (assoc clst :center (weighted-mean rns :weights weights)))))
      clsts)
    ; Remove the nils, they break the math
    (remove nil? clsts)
    ; If nothing is left, make one great big cluster - so that things don't break in most-distal later
    ; XXX - Should see if there is a cleaner place/way to handle this...
    (if (empty? clsts)
      [{:id (inc (apply max (map :id clusters)))
        :members (nm/rownames data)
        :center (weighted-mean data :weights weights)}]
      clsts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn merge-clusters [clst1 clst2]
  (let [new-id (:id (max-key #(count (:members %)) clst1 clst2))]
    {:id new-id
     :members (into (:members clst1) (:members clst2))
     :center (weighted-mean (map :center [clst1 clst2])
                            :weights (map (comp count :members) [clst1 clst2]))}))</pre></td></tr><tr><td class="docs"><p>Finds the most distal point in all clusters</p>
</td><td class="codes"><pre class="brush: clojure">(defn most-distal
  [data clusters]
  (let [[dist clst-id id]
          ; find the maximum dist, clst-id, mem-id triple
          (apply max-key #(get % 0)
            (map
              (fn [mem]
                ; Find the minimum distance, cluster-id pair, and add the member name to the end
                (conj (apply min-key #(get % 0)
                        (map
                          #(vector (matrix/distance (nm/get-row-by-name data mem) (:center %)) (:id %))
                          clusters))
                   mem))
              (nm/rownames data)))]
    {:dist dist :clst-id clst-id :id id}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn uniqify-clusters [clusters]
  (reduce
    (fn [clusters clst]
      (let [identical-clst (first (filter #(= (:center clst) (:center %)) clusters))]
        (if identical-clst
          (assoc clusters (utils/typed-indexof clusters identical-clst) (merge-clusters identical-clst clst))
          (conj clusters clst))))
    [] clusters))</pre></td></tr><tr><td class="docs"><p>This function takes care of some possible messy situations which can crop up with using 'last-clusters'
  in kmeans computation, and generally gets the last set of clusters ready as the basis for a new round of
  clustering given the latest set of data.</p>
</td><td class="codes"><pre class="brush: clojure">(defn clean-start-clusters
  [data clusters k &amp; {:keys [weights]}]
  ; First recenter clusters (replace cluster center with a center computed from new positions)
  (let [clusters (into [] (safe-recenter-clusters data clusters :weights weights))
        ; next make sure we're not dealing with any clusters that are identical to eachother
        uniq-clusters (uniqify-clusters clusters)
        ; count uniq data points to figure out how many clusters are possible
        possible-clusters (min k (count (distinct (matrix/rows (nm/get-matrix data)))))]
    (loop [clusters uniq-clusters]
      ; Whatever the case here, we want to do one more recentering
      (let [clusters (recenter-clusters data clusters :weights weights)]
        (if (&gt; possible-clusters (count clusters))
          ; first find the most distal point, and the cluster to which it's closest
          (let [outlier (most-distal data clusters)]
            (if (&gt; (:dist outlier) 0)
              ; There is work to be done, so do it
              (recur
                (-&gt;
                  ; first remove the most distal point from the cluster it was in;
                  (map
                    (fn [clst]
                      (assoc clst :members
                        (remove (set [(:id outlier)]) (:members clst))))
                    clusters)
                  ; next add a new cluster containing only said point.
                  (conj {:id (inc (apply max (map :id clusters)))
                         :members [(:id outlier)]
                         :center (nm/get-row-by-name data (:id outlier))})))
              ; Else just return recentered clusters
              clusters))
          ; Else just return recentered clusters
          clusters)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn setify-members
  [clsts &amp; {:keys [trans] :or {trans identity}}]
  (-&gt;&gt; clsts
       (map (pc/fn-&gt;&gt; :members (map trans) set))
       (set)))</pre></td></tr><tr><td class="docs"><p>Given a clustering, creates a set of member sets. This makes it easy to compare clusters for equality.
  Optional <code>:trans</code> keyword args lets you perform a transformation to the member names included in member
  sets.</p>
</td><td class="codes"><pre class="brush: clojure">(defn simplify-clsts
  [clsts &amp; {:keys [trans] :or {trans identity}}]
  {:members (map
              (pc/fn-&gt;&gt; :members (map trans) set)
              clsts)
   :center (map
             (pc/fn-&gt;&gt; :center (mapv #(utils/round-to % 4)))
             clsts)})</pre></td></tr><tr><td class="docs"><p>Performs a k-means clustering.</p>
</td><td class="codes"><pre class="brush: clojure">(defn kmeans
  [data k &amp; {:keys [last-clusters max-iters weights] :or {max-iters 20}}]
  (let [data-iter (utils/zip (nm/rownames data) (matrix/matrix (nm/get-matrix data)))
        clusters  (if last-clusters
                    (clean-start-clusters data last-clusters k :weights weights)
                    (init-clusters data k))]
    (loop [clusters clusters iter max-iters]
      (let [new-clusters (cluster-step data-iter k clusters :weights weights)]
        (if (or (= iter 0) (same-clustering? clusters new-clusters))
          new-clusters
          (recur new-clusters (dec iter)))))))</pre></td></tr><tr><td class="docs"><p>Dist matrix</p>
</td><td class="codes"><pre class="brush: clojure">(defn dist-matrix
  ([m] (dist-matrix m m))
  ([m1 m2]
   (matrix/matrix
     (map
       (fn [r1]
         (map
           (fn [r2]
             (matrix/distance r1 r2))
           m2))
       m1))))</pre></td></tr><tr><td class="docs"><p>Distance matrix with rownames and colnames corresponding to rownames of nm1 and nm2 respectively.</p>
</td><td class="codes"><pre class="brush: clojure">(defn named-dist-matrix
  ([nm] (named-dist-matrix nm nm))
  ([nm1 nm2]
   (nm/named-matrix
     (nm/rownames nm1)
     (nm/rownames nm2)
     (dist-matrix (nm/get-matrix nm1) (nm/get-matrix nm2)))))</pre></td></tr><tr><td class="docs"><p>Compute the silhoette coefficient for either a cluster member, or for an entire clustering. Currently,
  the latter just averages over the former for all members - it's likely there is a more efficient way
  to block things up.</p>
</td><td class="codes"><pre class="brush: clojure">(defn silhouette
  ([distmat clusters member]
   (let [dist-row (nm/rowname-subset distmat [member])
         [a b]
           (reduce
             (fn [[a b] clst]
               (let [memb-clst? (some #{member} (:members clst))
                     membs (remove #{member} (:members clst))]
                 ; This is a little bit silly, but will basically trigger returning 0 if member is in a
                 ; singleton cluster
                 (if (and memb-clst? (empty? membs))
                   (reduced [1 1])
                   ; Otherwise, continue...
                   (as-&gt; membs data
                     ; Subset to just the columns for this clusters
                     (nm/colname-subset dist-row data)
                     (nm/get-matrix data)
                     ; This is a 2D row vector; we want 1D, so take first
                     (first data)
                     ; Take the mean of the entries
                     (matrix-stats/mean data)
                     (if memb-clst?
                       [data b]
                       [a (min data (or b data))])))))
             [nil nil]
             clusters)]
     ; The actual silhouette computation
     (/ (- b a) (max b a))))
  ([distmat clusters]
   (weighted-mean
     (map
       (partial silhouette distmat clusters)
       (nm/rownames distmat)))))</pre></td></tr><tr><td class="docs"><p>Given group-clusters group and base clusters, get the members for the group</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-members
  [group base-clusters]
  (let [group-bids (set (:members group))]
    (-&gt;&gt; base-clusters
         (filter #(group-bids (:id %)))
         (map :members)
         (apply concat))))</pre></td></tr><tr><td class="docs"><p>Takes clusters -- a seq of maps <code>{:members :id :center}</code> -- and transforms into a single map
  <code>{:id :members :x :y :count}</code>, where each key points to a seq of the values associated with each
  cluster. In particular, this is what's used to format base clusters for mongo uploading (for the
  sake of compression).</p>
</td><td class="codes"><pre class="brush: clojure">(defn fold-clusters
  [clusters]
  {:id      (map :id clusters)
   :members (map :members clusters)
   :x       (map (comp first :center) clusters)
   :y       (map (comp second :center) clusters)
   :count   (map (comp count :members) clusters)})</pre></td></tr><tr><td class="docs"><p>The inverse of <code>fold-clusters</code>; takes folded clusters and puts them into standard form.
  i.e. <code>(= identity (comp unfold-clusters fold-clusters))</code></p>
</td><td class="codes"><pre class="brush: clojure">(defn unfold-clusters
  [{:keys [members id x y] :as folded-clusters}]
  (map
    (fn [ms id x y]
      {:id id
       :members ms
       :center [x y]})
    members
    id
    x
    y))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn xy-clusters-to-nmat [clusters]
  (let [nmat (nm/named-matrix)]
    (nm/update-nmat
     nmat
     (apply concat ; flatten the list of lists below
      (mapv
       (fn [cluster]
         (let [center (:center cluster)
               id (:id cluster)]
           ; Return some values that we can feed to update-nmat
           [[id :x (first center)]
            [id :y (second center)]]))
       clusters)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn xy-clusters-to-nmat2 [clusters]
  (nm/named-matrix
    (map :id clusters) ; row names
    [:x :y] ; column names
    (matrix/matrix (map :center clusters))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.math.conversation" name="polismath.math.conversation"><h1 class="project-name">polismath.math.conversation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.math.conversation
  (:refer-clojure :exclude [* -  + == /])
  (:require [polismath.utils :as utils]
            [polismath.math.pca :as pca]
            [polismath.math.clusters :as clusters]
            [polismath.math.repness :as repness]
            [polismath.math.named-matrix :as nm]
            [clojure.core.matrix :as matrix]
            [clojure.tools.reader.edn :as edn]
            [clojure.tools.trace :as tr]
            [clojure.math.numeric-tower :as math]
            [clojure.core.matrix :as matrix]
            [clojure.core.matrix.operators :refer :all]
            [plumbing.core :as plmb]
            [plumbing.graph :as graph]
            [monger.collection :as mc]
            [bigml.sampling.simple :as sampling]
            ;[alex-and-georges.debug-repl :as dbr]
            [clojure.tools.logging :as log]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn new-conv []
  &quot;Minimal structure upon which to perform conversation updates&quot;
  {:rating-mat (nm/named-matrix)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn choose-group-k [base-clusters]
  (let [len (count base-clusters)]
    (cond
      (&lt; len 99) 3
      :else 4)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn agg-bucket-votes-for-tid [bid-to-pid rating-mat filter-cond tid]
  (if-let [idx (nm/index (nm/get-col-index rating-mat) tid)]
    ; If we have data for the given comment...
    (let [pid-to-row (zipmap (nm/rownames rating-mat) (range (count (nm/rownames rating-mat))))
          person-rows (nm/get-matrix rating-mat)]
      (mapv ; for each bucket
        (fn [pids]
          (-&gt;&gt; pids
            ; get votes for the tid from each ptpt in group
            (map (fn [pid] (get (get person-rows (pid-to-row pid)) idx)))
            ; filter votes you don't want to count
            (filter filter-cond)
            ; count
            (count)))
        bid-to-pid))
    ; Otherwise return an empty vector
    []))</pre></td></tr><tr><td class="docs"><p>Base of all conversation updates; handles default update opts and does named matrix updating</p>
</td><td class="codes"><pre class="brush: clojure">(def base-conv-update-graph
  {:opts'       (plmb/fnk [opts]
                  &quot;Merge in opts with the following defaults&quot;
                  (merge {:n-comps 2
                          :pca-iters 10
                          :base-iters 10
                          :base-k 50
                          :max-k 5
                          :group-iters 10
                          :max-ptpts 80000
                          :max-cmts 800
                          :group-k-buffer 4}
                    opts))
   :zid         (plmb/fnk [conv votes]
                  (or (:zid conv)
                      (:zid (first votes))))
   :last-vote-timestamp
                (plmb/fnk [conv votes]
                  (apply max
                         (or (:last-vote-timestamp conv) 0)
                         (map :created votes)))
   :customs     (plmb/fnk [conv votes opts']
                  ; Decides whether there is room for new ptpts/cmts, and which votes should be allowed in
                  ; based on which ptpts/cmts have already been seen. This is a simple prevention against
                  ; conversations that get too large. Returns {:pids :tids :votes}, where the first two kv
                  ; pairs are persisted and built upon and persisted; :votes is used downstream and tossed
                  (reduce
                    (fn [{:keys [pids tids] :as result}
                         {:keys [pid  tid]  :as vote}]
                      (let [pid-room (&lt; (count pids) (:max-ptpts opts'))
                            tid-room (&lt; (count tids) (:max-cmts opts'))
                            pid-in   (pids pid)
                            tid-in   (tids tid)]
                        (if (and (or pid-room pid-in)
                                 (or tid-room tid-in))
                          (assoc result
                                 :pids  (conj (:pids result)  pid)
                                 :tids  (conj (:tids result)  tid)
                                 :votes (conj (:votes result) vote))
                          result)))
                    ; Customs collection off which to base reduction; note that votes get cleared out
                    (assoc (or (:customs conv) {:pids #{} :tids #{}})
                      :votes [])
                    votes))
   :keep-votes  (plmb/fnk [customs]
                  (:votes customs))
   :rating-mat  (plmb/fnk [conv keep-votes]
                  (nm/update-nmat (:rating-mat conv)
                                  (map (fn [v] (vector (:pid v) (:tid v) (:vote v))) keep-votes)))
   :n           (plmb/fnk [rating-mat]
                  (count (nm/rownames rating-mat)))
   :n-cmts      (plmb/fnk [rating-mat]
                  (count (nm/colnames rating-mat)))
   :user-vote-counts
                (plmb/fnk [rating-mat]
                  ; For deciding in-conv below; filter ptpts based on how much they've voted
                  (mapv
                    (fn [rowname row] [rowname (count (remove nil? row))])
                    (nm/rownames rating-mat)
                    (nm/get-matrix rating-mat)))
   :in-conv     (plmb/fnk [conv user-vote-counts n-cmts]
                  ; This keeps track of which ptpts are in the conversation (to be considered
                  ; for base-clustering) based on home many votes they have. Once a ptpt is in,
                  ; they will remain in.
                  (as-&gt; (or (:in-conv conv) #{}) in-conv
                    ; Start with whatever you have, and join it with anything that meets the criteria
                    (into in-conv
                      (map first
                        (filter
                          (fn [[rowname cnt]]
                            ; We only start looking at a ptpt if they have rated either all the comments or at
                            ; least 7 if there are more than 7
                            (&gt;= cnt (min 7 n-cmts)))
                          user-vote-counts)))
                    ; If you are left with fewer than 15 participants, take the top most contributing
                    ; participants
                    (let [greedy-n 15
                          n-in-conv (count in-conv)]
                      (if (&lt; n-in-conv greedy-n)
                        (-&gt;&gt; user-vote-counts
                          (remove
                            (fn [[k v]] (in-conv k)))
                          (sort-by (comp - second))
                          (map first)
                          (take (- greedy-n n-in-conv))
                          (into in-conv))
                        in-conv))))
  ; End of base conv update
  })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn max-k-fn
  [data max-max-k]
  (min
    max-max-k
    (+ 2
       (int (/ (count (nm/rownames data)) 12)))))</pre></td></tr><tr><td class="docs"><p>For computing small conversation updates (those without need for base clustering)</p>
</td><td class="codes"><pre class="brush: clojure">(def small-conv-update-graph
  (merge
     base-conv-update-graph
     {:mat (plmb/fnk [rating-mat]
             ; swap nils for zeros - most things need the 0s, but repness needs the nils&quot;
             (mapv (fn [row] (map #(if (nil? %) 0 %) row))
               (nm/get-matrix rating-mat)))
      :pca (plmb/fnk [conv mat opts']
             (pca/wrapped-pca mat
                              (:n-comps opts')
                              :start-vectors (get-in conv [:pca :comps])
                              :iters (:pca-iters opts')))
      :proj (plmb/fnk [rating-mat pca]
              (pca/sparsity-aware-project-ptpts (nm/get-matrix rating-mat) pca))
      :base-clusters
            (plmb/fnk [conv rating-mat proj in-conv opts']
              (let [proj-mat (nm/named-matrix (nm/rownames rating-mat) [&quot;x&quot; &quot;y&quot;] proj)
                    in-conv-mat (nm/rowname-subset proj-mat in-conv)]
                (sort-by :id
                  (clusters/kmeans in-conv-mat
                    (:base-k opts')
                    :last-clusters (:base-clusters conv)
                    :cluster-iters (:base-iters opts')))))
      :base-clusters-proj
            (plmb/fnk [base-clusters]
              (clusters/xy-clusters-to-nmat2 base-clusters))
      :bucket-dists
            (plmb/fnk [base-clusters-proj]
              (clusters/named-dist-matrix base-clusters-proj))
      :base-clusters-weights
            (plmb/fnk [base-clusters]
              (into {}
                    (map
                      (fn [clst]
                        [(:id clst) (count (:members clst))])
                      base-clusters)))
      ; Compute group-clusters for multiple k values
      :group-clusterings
            (plmb/fnk [conv base-clusters-weights base-clusters-proj opts']
                (plmb/map-from-keys
                  (fn [k]
                    (sort-by :id
                      (clusters/kmeans base-clusters-proj k
                        :last-clusters
                          ; A little pedantic here in case no clustering yet for this k
                          (let [last-clusterings (:group-clusterings conv)]
                            (if last-clusterings
                              (last-clusterings k)
                              last-clusterings))
                        :cluster-iters (:group-iters opts')
                        :weights base-clusters-weights)))
                  (range 2 (inc (max-k-fn base-clusters-proj (:max-k opts'))))))
      ; Compute silhouette values for the various clusterings
      :group-clusterings-silhouettes
            (plmb/fnk [group-clusterings bucket-dists]
              (plmb/map-vals (partial clusters/silhouette bucket-dists) group-clusterings))
      ; This smooths changes in cluster counts (K-vals) by remembering what the last K was, and only changing
      ; after (:group-k-buffer opts') many times on a new K value
      :group-k-smoother
            (plmb/fnk
              [conv group-clusterings group-clusterings-silhouettes opts']
              (let [{:keys [last-k last-k-count smoothed-k] :or {last-k-count 0}}
                      (:group-k-smoother conv)
                    count-buffer (:group-k-buffer opts')
                                 ; Find best K value for current data, given silhouette
                    this-k       (apply max-key group-clusterings-silhouettes (keys group-clusterings))
                                 ; If this and last K values are the same, increment counter
                    same         (if last-k (= this-k last-k) false)
                    this-k-count (if same (+ last-k-count 1) 1)
                                 ; if seen &gt; buffer many times, switch, OW, take last smoothed
                    smoothed-k   (if (&gt;= this-k-count count-buffer)
                                   this-k
                                   (if smoothed-k smoothed-k this-k))]
                {:last-k       this-k
                 :last-k-count this-k-count
                 :smoothed-k   smoothed-k}))
      ; Pick the cluster corresponding to smoothed K value from group-k-smoother
      :group-clusters
            (plmb/fnk [group-clusterings group-k-smoother]
              (get group-clusterings
                (:smoothed-k group-k-smoother)))
      :bid-to-pid (plmb/fnk [base-clusters]
                    (mapv :members (sort-by :id base-clusters)))
      ;; returns {tid {
      ;;           :agree [0 4 2 0 6 0 0 1]
      ;;           :disagree [3 0 0 1 0 23 0 ]}
      ;; where the indices in the arrays correspond NOT directly to the bid, but to the index of the
      ;; corresponding bid in a hypothetically sorted list of the base cluster ids
      :votes-base (plmb/fnk [bid-to-pid rating-mat]
                    (-&gt;&gt; rating-mat
                      nm/colnames
                      (plmb/map-from-keys
                        (fn [tid]
                          {:A (agg-bucket-votes-for-tid bid-to-pid rating-mat utils/agree? tid)
                           :D (agg-bucket-votes-for-tid bid-to-pid rating-mat utils/disagree? tid)
                           :S (agg-bucket-votes-for-tid bid-to-pid rating-mat number? tid)}))))
      ; {tid {gid {A _ D _ S}}}
      :group-votes (plmb/fnk [group-clusters base-clusters votes-base]
                     (let [bid-to-index (zipmap (map :id base-clusters)
                                                (range))]
                       (into {}
                         (map
                           (fn [{:keys [id members] :as group-cluster}]
                             (letfn [(count-fn [tid vote]
                                       (-&gt;&gt;
                                         members
                                         (mapv bid-to-index)
                                         (mapv #(((votes-base tid) vote) %))
                                         (apply +)))]
                               [id
                                {:n-members (let [bids (set members)]
                                              ; Add up the count of members in each base-cluster in this group-cluster
                                              (-&gt;&gt; base-clusters
                                                   (filter #(bids (:id %)))
                                                   (map #(count (:members %)))
                                                   (reduce + 0)))
                                 :votes (plmb/map-from-keys
                                          (fn [tid]
                                            {:A (count-fn tid :A)
                                             :D (count-fn tid :D)
                                             :S (count-fn tid :S)})
                                          (keys votes-base))}]))
                           group-clusters))))
      :repness    (plmb/fnk [conv rating-mat group-clusters base-clusters]
                    (-&gt; (repness/conv-repness rating-mat group-clusters base-clusters)
                        (repness/select-rep-comments (:mod-out conv))))
      :consensus  (plmb/fnk [conv rating-mat]
                    (-&gt; (repness/consensus-stats rating-mat)
                        (repness/select-consensus-comments (:mod-out conv))))
     ; End of large-update
     }))</pre></td></tr><tr><td class="docs"><p>This function takes in the rating matrix, the current pca and a set of row indices and
  computes the partial pca off of those, returning a lambda that will take the latest PCA 
  and make the update on that in case there have been other mini batch updates since started</p>
</td><td class="codes"><pre class="brush: clojure">(defn partial-pca
  [mat pca indices &amp; {:keys [n-comps iters learning-rate]
                      :or {n-comps 2 iters 10 learning-rate 0.01}}]
  (let [rating-subset (utils/filter-by-index mat indices)
        part-pca (pca/powerit-pca rating-subset n-comps
                     :start-vectors (:comps pca)
                     :iters iters)
        forget-rate (- 1 learning-rate)
        learn (fn [old-val new-val]
                (let [old-val (matrix/join old-val (repeat (- (matrix/dimension-count new-val 0)
                                                              (matrix/dimension-count old-val 0)) 0))]
                  (+ (* forget-rate old-val) (* learning-rate new-val))))]
    (fn [pca']
      ; Actual updater lambda&quot;
      {:center (learn (:center pca') (:center part-pca))
       :comps  (mapv #(learn %1 %2) (:comps pca') (:comps part-pca))})))</pre></td></tr><tr><td class="docs"><p>Return a function which decides how many ptpts to sample for mini-batch updates; the input
  parameters correspond to a line of sample sizes to interpolate. Beyon the bounds of these
  points, the sample sizes flatten out so all sample sizes lie in [start-y stop-y]</p>
</td><td class="codes"><pre class="brush: clojure">(defn sample-size-fn
  [start-y stop-y start-x stop-x]
  (let [slope (/ (- stop-y start-y) (- stop-x start-x))
        start (- (* slope start-x) start-y)]
    (fn [size]
      (max 
        (long (min (+ start (* slope size)) stop-y))
        start-y))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def sample-size (sample-size-fn 100 1500 1500 150000))</pre></td></tr><tr><td class="docs"><p>Same as small-conv-update-graph, but uses mini-batch PCA</p>
</td><td class="codes"><pre class="brush: clojure">(def large-conv-update-graph
  (merge small-conv-update-graph
    {:pca (plmb/fnk [conv mat opts']
            (let [n-ptpts (matrix/dimension-count mat 0)
                  sample-size (sample-size n-ptpts)]
              (loop [pca (:pca conv) iter (:pca-iters opts')]
                (let [rand-indices (take sample-size (sampling/sample (range n-ptpts) :generator :twister))
                      pca          ((partial-pca mat pca rand-indices) pca)]
                  (if (= iter 0)
                    (recur pca (dec iter))
                    pca)))))}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def eager-profiled-compiler
  (comp graph/eager-compile (partial graph/profiled :profile-data)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def small-conv-update (eager-profiled-compiler small-conv-update-graph))
(def large-conv-update (eager-profiled-compiler large-conv-update-graph))</pre></td></tr><tr><td class="docs"><p>This function dispatches to either small- or large-conv-update, depending on the number
  of participants (as decided by call to sample-size-fn).</p>
</td><td class="codes"><pre class="brush: clojure">(defn conv-update
  ;; XXX This function is going to need to take config component for cutoff values
  ;; XXX Also need to set the max globally and by conversation for plan throttling
  [conv votes &amp; {:keys [med-cutoff large-cutoff]
                                 :or {med-cutoff 100 large-cutoff 10000}
                                 :as opts}]
  (let [zid     (or (:zid conv) (:zid (first votes)))
        _ (log/info &quot;Conv update started for zid:&quot; zid)
        ptpts   (nm/rownames (:rating-mat conv))
        n-ptpts (count (distinct (into ptpts (map :pid votes))))
        n-cmts  (count (distinct (into (nm/rownames (:rating-mat conv)) (map :tid votes))))]
    ; This is a safety measure so we can call conv-update on an empty conversation after adding mod-out
    (if (and (= 0 n-ptpts n-cmts)
             (empty? votes))
      conv
      (do
        (log/info (str &quot;Starting conv-update for zid &quot; zid &quot;: N=&quot; n-ptpts &quot;, C=&quot; n-cmts &quot;, V=&quot; (count votes)))
        (-&gt;
          ; dispatch to the appropriate function
          ((cond
             (&gt; n-ptpts large-cutoff)  large-conv-update
             :else                     small-conv-update)
                {:conv conv :votes votes :opts opts})
          ; Remove the :votes key from customs; not needed for persistence
          (assoc-in [:customs :votes] [])
          (dissoc :keep-votes))))))</pre></td></tr><tr><td class="docs"><p>Take a conversation record and a seq of moderation data and updates the conversation's mod-out attr</p>
</td><td class="codes"><pre class="brush: clojure">(defn mod-update
  [conv mods]
  ; Hmm... really need to make sure that if someone quickly mods and unmods on a long running comp, we
  ; consider order or :updated XXX
  (try
    (let [mod-sep (fn [mod] (-&gt;&gt; mods
                                 (filter (comp #{mod} :mod))
                                 (map :tid)
                                 (set)))
          mod-out (mod-sep -1)
          mod-in  (mod-sep 1)]
      (-&gt; conv
          (update-in [:mod-out]
                     (plmb/fn-&gt;
                       (set)
                       (clojure.set/union mod-out)
                       (clojure.set/difference mod-in)
                       (set)))
          (update-in [:last-mod-timestamp]
                     (fn [last-mod-timestamp]
                       (apply max (or last-mod-timestamp 0) (map :modified mods))))))
    (catch Exception e
      (log/error &quot;Problem running mod-update with mod-out:&quot; (:mod-out conv) &quot;and mods:&quot; mods &quot;:&quot; e)
      (.printStackTrace e)
      conv)))</pre></td></tr><tr><td class="docs"><p>Creating some overrides for how core.matrix instances are printed, so that we can read them back via our
edn reader</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ipv-print-method (get (methods print-method) clojure.lang.IPersistentVector))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method mikera.matrixx.Matrix
  [o ^java.io.Writer w]
  (.write w &quot;#mikera.matrixx.Matrix &quot;)
  (ipv-print-method
    (mapv #(into [] %) o)
    w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method mikera.vectorz.Vector
  [o ^java.io.Writer w]
  (.write w &quot;#mikera.vectorz.Vector &quot;)
  (ipv-print-method o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method mikera.arrayz.NDArray
  [o ^java.io.Writer w]
  (.write w &quot;#mikera.arrayz.NDArray &quot;)
  (ipv-print-method o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn read-vectorz-edn [text]
  (edn/read-string
    {:readers {'mikera.vectorz.Vector matrix/matrix
               'mikera.arrayz.NDArray matrix/matrix
               'mikera.matrixx.Matrix matrix/matrix
               'polismath.named-matrix.NamedMatrix nm/named-matrix-reader}}
    text))</pre></td></tr><tr><td class="docs"><p>Write out conversation state, votes, computational opts and error for debugging purposes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn conv-update-dump
  [conv votes &amp; [opts error]]
  (spit (str &quot;errorconv.&quot; (. System (nanoTime)) &quot;.edn&quot;)
    (prn-str
      {:conv  (into {}
                (assoc-in conv [:pca :center] (matrix/matrix (into [] (:center (:pca conv))))))
       :votes votes
       :opts  opts
       :error (str error)})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn load-conv-update [filename]
  (read-vectorz-edn (slurp filename)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.math.named-matrix" name="polismath.math.named-matrix"><h1 class="project-name">polismath.math.named-matrix</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.math.named-matrix
  (:require [clojure.core.matrix :as cm]
            [clojure.core.matrix.select :as cm-sel]
            [taoensso.timbre.profiling :as profiling :refer (pspy pspy* profile defnp p p*)])
  ;; Again, move to 
  (:use polismath.utils))</pre></td></tr><tr><td class="docs"><p>Things which implement this are intended to be used as data structures for use as rownames or colnames.
  They are basically overglorified hash maps</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol AutoIncIndex
  (get-names [this] &quot;In order of index, the names associated with the data&quot;)
  (next-index [this] &quot;Get the next available index&quot;)
  (index [this keyname] &quot;Get the index corresponding to keyname&quot;)
  (append [this keyname] &quot;Append keyname&quot;)
  (append-many [this keynames] &quot;Append many&quot;)
  (subset [this keynames] &quot;Subset the index, and update index/hash&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype IndexHash
  [^java.util.Vector names ^clojure.lang.PersistentArrayMap index-hash]
  AutoIncIndex
    (get-names [this] (.names this))
    (next-index [this] (count (.names this)))
    (index [this keyname] (index-hash keyname))
    (append [this keyname]
      (if ((.index-hash this) keyname)
        this
        (IndexHash.
          (conj (get-names this) keyname)
          (assoc (.index-hash this) keyname (next-index this)))))
    (append-many [this keynames]
      ; potentially faster
      ;(let [uniq-kns (distinct keynames)
            ;new-kns (remove (.index-hash this) uniq-kns)]
        ;(IndexHash.
          ;(into (.names this) new-kns)
          ;(into (.index-hash)
            ;(map
              ;#(vector %1 (+ (count (.names this)) %2))
              ;new-kns
              ;(range)))))
      ; much simpler
      (reduce append this keynames))
    (subset [this keynames]
      (let [kn-set (set keynames)
            new-kns (filter kn-set (.names this))]
        (IndexHash. new-kns (into {} (map vector new-kns (range)))))))</pre></td></tr><tr><td class="docs"><p>Construct a new IndexHash with the given keynames</p>
</td><td class="codes"><pre class="brush: clojure">(defn index-hash
  [keynames]
  (let [uniq-kns (into [] (distinct keynames))]
    (IndexHash. uniq-kns
      (into {} (map vector uniq-kns (range))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PNamedMatrix
  ; should really just change to update, but for now...
  (update-nmat [this values]
    &quot;Updates a nameable matrix given a seq of (rowname, colname, value) tuples&quot;)
  (rownames [this] &quot;Vector of row names, in order&quot;)
  (colnames [this] &quot;Vector of column names, in order&quot;)
  (get-matrix [this] &quot;Extract the matrix object&quot;)
  ; XXX - Should probably set these up map [this key] -&gt; (index (.row-index this) key) since that's whats needed
  (get-row-index [this] &quot;Extract the row-index object&quot;)
  (get-col-index [this] &quot;Extract the col-index object&quot;)
  (rowname-subset [this names] &quot;Get a new PNamedMatrix subsetting to just the given rownames&quot;)
  (colname-subset [this names] &quot;Get a new PNamedMatrix subsetting to just the given columns&quot;))</pre></td></tr><tr><td class="docs"><p>Adds specified value padding to 2d matrices</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-padding
  [mat ^Integer dim ^Integer n &amp; [value]]
  (let [other-dim (mod (inc dim) 2)
        other-dimcount (cm/dimension-count mat other-dim)]
    (case dim
      0 (let [padding (into [] (repeat other-dimcount value))]
          (into mat (repeat n padding)))
      1 (let [padding (repeat n value)]
          (mapv #(into % padding) mat)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype NamedMatrix
  [row-index col-index ^java.util.Vector matrix]
  PNamedMatrix
    (update-nmat [this values]
      ; First find the row and column names that aren't yet in the data
      (let [[missing-rows missing-cols]
              (reduce
                (fn [[missing-rows missing-cols] [row col value]]
                  [(if (nil? (index (.row-index this) row))
                     (conj missing-rows row)
                     missing-rows)
                   (if (nil? (index (.col-index this) col))
                     (conj missing-cols col)
                     missing-cols)])
                [[] []]
                values)
            ; Construct new rowname and colname hash-indices
            new-row-index (append-many (.row-index this) missing-rows)
            new-col-index (append-many (.col-index this) missing-cols)
            new-row-count (count (set missing-rows))
            new-col-count (count (set missing-cols))]
        ; Construct a new NamedMatrix
        (NamedMatrix.
          new-row-index
          new-col-index
          ; Construct new matrix
          (as-&gt; (.matrix this) mat
            (if (= 0 (cm/dimension-count mat 1))
              ; If the matrix is empty, just create the shape needed
              (cm/coerce [[]]
                (cm/broadcast nil [new-row-count new-col-count]))
              ; OW, add padding of nils for new rows/cols
              (-&gt; mat
                (add-padding 1 (count (set missing-cols)))
                (add-padding 0 (count (set missing-rows)))))
            ; Next assoc-in all of the new votes
            (reduce
              (fn [mat' [row col value]]
                (let [row-i (index new-row-index row)
                      col-i (index new-col-index col)]
                  (assoc-in mat' [row-i col-i] value)))
              mat
              values)))))
    (rownames [this] (get-names (.row-index this)))
    (colnames [this] (get-names (.col-index this)))
    (get-matrix [this] (.matrix this))
    (get-row-index [this] (.row-index this))
    (get-col-index [this] (.col-index this))
    (rowname-subset [this names]
      (let [row-indices (map (partial index (.row-index this)) names)
            row-index (subset (.row-index this) names)]
        (NamedMatrix.
          row-index
          (.col-index this)
          (filter-by-index (.matrix this) row-indices))))
    (colname-subset [this names]
      (let [col-indices (map (partial index (.col-index this)) names)
            col-index (subset (.col-index this) names)]
        (NamedMatrix.
          (.row-index this)
          col-index
          (cm-sel/sel (.matrix this) (cm-sel/irange) col-indices)))))</pre></td></tr><tr><td class="docs"><p>Generator function for a new named matrix</p>
</td><td class="codes"><pre class="brush: clojure">(defn named-matrix
  [&amp; [rows cols matrix]]
  (NamedMatrix.
    (index-hash (or rows []))
    (index-hash (or cols []))
    (or matrix [[]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method NamedMatrix
  [nm ^java.io.Writer w]
  (.write w
    (str &quot;#polismath.named-matrix.NamedMatrix &quot;
      &quot;{:rownames &quot; (into [] (rownames nm))
      &quot; :colnames &quot; (into [] (colnames nm))
      &quot; :matrix &quot; (get-matrix nm)
      &quot;}&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn named-matrix-reader
  [{:keys [rownames colnames matrix]}]
  (named-matrix rownames colnames matrix))</pre></td></tr><tr><td class="docs"><p>This version of rowname-subset filters out negative indices, so that if not all names in row-names
  are in nmat, it just subsets to the rownames that are. Should scrap other one?</p>
</td><td class="codes"><pre class="brush: clojure">(defn safe-rowname-subset
  [nmat names]
  (let [safe-names (filter
                     (partial index (get-row-index nmat))
                     names)]
    (rowname-subset nmat names)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-row-by-name [nmat row-name]
  (cm/get-row (get-matrix nmat) (index (get-row-index nmat) row-name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn inv-rowname-subset [nmat row-names]
  &quot;Returns named matrix which has been subset to all the rows not in row-names&quot;
  (rowname-subset nmat
    (remove (set row-names) (rownames nmat))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.math.pca" name="polismath.math.pca"><h1 class="project-name">polismath.math.pca</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.math.pca
  (:refer-clojure :exclude [* - + == /])
  (:require [clojure.tools.trace :as tr]
            [polismath.utils :as utils]
            [clojure.core.match :refer [match]]
            [clojure.core.matrix :as matrix]
            [clojure.core.matrix.stats :as matrix-stats]
            [clojure.core.matrix.operators :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(matrix/set-current-implementation :vectorz)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *unchecked-math* true)</pre></td></tr><tr><td class="docs"><p>Utility function for making a vector of length n composed entirely of x</p>
</td><td class="codes"><pre class="brush: clojure">(defn repeatv
  [n x]
  (matrix/matrix (into [] (repeat n x))))</pre></td></tr><tr><td class="docs"><p>Will need to rename this and some of the inner variables to be easier to read...
  Computes an inner step of the power-iteration process</p>
</td><td class="codes"><pre class="brush: clojure">(defn xtxr
  [data start-vec]
  (let [n-cols (matrix/dimension-count data 1)
        curr-vec (matrix/transpose (repeatv n-cols 0))]
    (loop [data (matrix/rows data) curr-vec curr-vec]
      (if-let [row (first data)]
        (recur (rest data)
               (+ curr-vec (* (matrix/inner-product start-vec row) row)))
        curr-vec))))</pre></td></tr><tr><td class="docs"><p>This function produces the first eigenvector of data using the power iteration method with
  iters iterations and starting vector start-vector (defaulting to 100 and 111111 resp).</p>
</td><td class="codes"><pre class="brush: clojure">(defn power-iteration
  [data &amp; [iters start-vector]]
  ; need to clean up some of these variables names to be more descriptive
  (let [iters (or iters 100)
        n-cols (matrix/dimension-count data 1)
        start-vector (or start-vector (repeatv n-cols 1))
        ; XXX - this add extra cols to the start vector if we have new comments... should test
        start-vector (matrix/matrix
                       (concat start-vector
                               (repeatv (- n-cols (matrix/dimension-count start-vector 0)) 1)))]
    (loop [iters iters start-vector start-vector last-eigval 0]
      (let [product-vector (xtxr data start-vector)
            eigval (matrix/length product-vector)
            normed (matrix/normalise product-vector)]
        (if (or (= iters 0) (= eigval last-eigval))
          normed
          (recur (dec iters) normed eigval))))))</pre></td></tr><tr><td class="docs"><p>This computes the projection of ys orthogonally onto the vector spanned by xs</p>
</td><td class="codes"><pre class="brush: clojure">(defn proj-vec
  [xs ys]
  (let [coeff (/ (matrix/dot xs ys) (matrix/dot xs xs))]
    (* coeff xs)))</pre></td></tr><tr><td class="docs"><p>As in the Gram-Shmidt process; we can 'factor out' the vector xs from all the vectors in data,
  such that there is no remaining variance in the xs direction within the data.</p>
</td><td class="codes"><pre class="brush: clojure">(defn factor-matrix
  [data xs]
  ; If we have a zero eigenvector, it's safe to just assume that 0 should remain the matrix
  (if (#{0 0.0} (matrix/dot xs xs))
    data
    ; Fucking weird... sometimes getting this &quot;can't convert to persistent vector array: inconcsistent shape&quot;
    ; error when we don't do the into [] here. Should need to though. Will have to figure out if there is some
    ; better solution
    (matrix/matrix (mapv #(into [] (- % (proj-vec xs %))) data))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rand-starting-vec [data]
  ;; Should really throw a parallelizable random number generator in the equation here...
  ;; With seeds fed in and persisted... XXX
  (matrix/matrix (for [x (range (matrix/dimension-count data 1))] (rand))))</pre></td></tr><tr><td class="docs"><p>Find the first n-comps principal components of the data matrix; iters defaults to iters of
  power-iteration</p>
</td><td class="codes"><pre class="brush: clojure">(defn powerit-pca
  [data n-comps &amp; {:keys [iters start-vectors]}]
  (let [center (matrix-stats/mean data)
        cntrd-data (- data center)
        start-vectors (or start-vectors [])
        data-dim (min (matrix/row-count cntrd-data) (matrix/column-count cntrd-data))]
    {:center center
     :comps
        (loop [data' cntrd-data n-comps' (min n-comps data-dim) pcs [] start-vectors start-vectors]
          ; may eventually want to return eigenvals...
          (let [start-vector (or (first start-vectors) (rand-starting-vec data))
                pc (power-iteration data' iters start-vector)
                pcs (conj pcs pc)]
            (if (= n-comps' 1)
              pcs ; return if done
              (let [data' (factor-matrix data' pc)
                    n-comps' (dec n-comps')]
                (recur data' n-comps' pcs (rest start-vectors))))))}))</pre></td></tr><tr><td class="docs"><p>This function gracefully handles weird edge cases inherent in the messiness of real world data</p>
</td><td class="codes"><pre class="brush: clojure">(defn wrapped-pca
  [data n-comps &amp; {:keys [iters start-vectors] :as kwargs}]
  (match (map (partial matrix/dimension-count data) [0 1])
    [1 n-cols]
      {:center (matrix/matrix (repeatv n-comps 0))
       :comps  (into [(matrix/normalise (matrix/get-row data 0))]
                 (repeat (dec n-comps) (repeatv n-cols 0)))}
    [n-rows 1]
      {:center (matrix/matrix [0])
       :comps  (matrix/matrix [1])}
    :else
      (utils/apply-kwargs powerit-pca data n-comps
                    (assoc kwargs :start-vectors
                      (if start-vectors
                        (map #(if (every? #{0 0.0} %) nil %) start-vectors)
                        nil)))))</pre></td></tr><tr><td class="docs"><p>Apply the principal component projection specified by pcs to the data</p>
</td><td class="codes"><pre class="brush: clojure">(defn pca-project
  [data {:keys [comps center]}]
  ; Here we map each row of data to it's projection
  ; XXX - still need to verify this...
  (matrix/mmul (- data center) (matrix/transpose comps)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sparsity-aware-project-ptpt
  [votes {:keys [comps center]}]
  ; reduce into the projected point [p1, p2]
  (let [n-cmnts   (count votes)
        [pc1 pc2] comps
        [n-votes p1 p2] ; (p1, p2) is the projection we build
          (reduce
            ; _-n is the nth entry in _
            (fn [[n-votes p1 p2] [x-n cntr-n pc1-n pc2-n]]
              ; if we have voted, do the thing
              (if x-n
                ; first subtract center
                (let [x-n' (- x-n cntr-n)]
                  ; then do a step in the dot product, and inc n-votes seen
                  [(inc n-votes)
                   (+ p1 (* x-n' pc1-n))
                   (+ p2 (* x-n' pc2-n))])
                ; ... ow (if haven't voted) return what was there
                [n-votes p1 p2]))
            [0 0.0 0.0]
            (utils/zip votes center pc1 pc2))]
    ; Now scale the projection by the following value, which pushes us out from the center
    (* (Math/sqrt (/ n-cmnts (max n-votes 1)))
       [p1 p2])))</pre></td></tr><tr><td class="docs"><p>Like pca-project, but only performs the projection on non-null values, and scales the projection
  according to how many responses we have gotten</p>
</td><td class="codes"><pre class="brush: clojure">(defn sparsity-aware-project-ptpts
  [data pca]
  (mapv #(sparsity-aware-project-ptpt % pca) data))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.math.repness" name="polismath.math.repness"><h1 class="project-name">polismath.math.repness</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.math.repness
  (:require [polismath.utils :as utils]
            [polismath.math.stats :as stats]
            [polismath.math.named-matrix :as nm]
            [polismath.math.clusters :as clusters]
            [clojure.core.matrix :as mat]
            [clojure.core.matrix.operators :refer :all]
            [clojure.core.matrix.select :as mselect]
            [clojure.tools.trace :as tr]
            [plumbing.core :as pc :refer [fnk map-vals &lt;-]]
            [plumbing.graph :as gr]
            ;[alex-and-georges.debug-repl :as dbr])
  (:refer-clojure :exclude [* - + == /]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(mat/set-current-implementation :vectorz)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- count-votes
  [votes &amp; [vote]]
  &quot;Utility function for counting the number of votes matching `vote`. Not specifying `vote` returns
  length of vote vector.&quot;
  (let [filt-fn (if vote #(= vote %) identity)]
    (count (filter filt-fn votes))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def comment-stats-graphimpl
  ; The graph implementation is in a closure so that we don't reify classes every time function is called.
  ; This can cause PermGen space crashes. This is used for both consensus and repness comments.
  (gr/eager-compile
    {:na (fnk [votes] (count-votes votes -1))
     :nd (fnk [votes] (count-votes votes  1))
     :ns (fnk [votes] (count-votes votes))
     ; XXX - Change when we flip votes!!!
     :pa (fnk [na ns] (/ (+ 1 na) (+ 2 ns)))
     :pd (fnk [nd ns] (/ (+ 1 nd) (+ 2 ns)))
     :pat (fnk [na ns] (stats/prop-test na ns))
     :pdt (fnk [nd ns] (stats/prop-test nd ns))}))</pre></td></tr><tr><td class="docs"><p>Vote count stats for a given vote column. This vote column should represent the votes for a specific
  comment and group. Comparisons <em>between</em> groups happen later. See <code>(doc conv-repness)</code> for key details.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- comment-stats
  [vote-col]
  (comment-stats-graphimpl {:votes vote-col}))</pre></td></tr><tr><td class="docs"><p>Builds on results of comment-stats by doing comparisons <em>between</em> groups. Args are
  in group stats (as returned by comment-stats), and list of stats for rest of groups.
  See <code>(doc conv-repness)</code> for key details.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- add-comparitive-stats
  [in-stats rest-stats]
  (assoc in-stats
    :ra (/ (:pa in-stats)
           (/ (+ 1 (pc/sum :na rest-stats))
              (+ 2 (pc/sum :ns rest-stats))))
    :rd (/ (:pd in-stats)
           (/ (+ 1 (pc/sum :nd rest-stats))
              (+ 2 (pc/sum :ns rest-stats))))
    :rat (stats/two-prop-test (:na in-stats) (pc/sum :na rest-stats)
                        (:ns in-stats) (pc/sum :ns rest-stats))
    :rdt (stats/two-prop-test (:nd in-stats) (pc/sum :nd rest-stats) 
                        (:ns in-stats) (pc/sum :ns rest-stats))))</pre></td></tr><tr><td class="docs"><p>Computes representativeness (repness) for a given data set, group clustering and base clustering,
  returned as a map <code>{:ids __ :stats __}</code>. The <code>:stats</code> key maps to a sequences of results, one for each
  group cluster, each of which is a sequence where the positional index corresponds to a particular
  comment, and each value is a hash-map of statistics for the given group/comment. The hash keys obey the
  following legend:
    n=#, p=prob, r=rep, t=test, a=agree, d=disagree, s=seen
  The :ids key maps to a vector of group ids in the same order they appear in the :stats sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn conv-repness
  [data group-clusters base-clusters]
  {:ids (map :id group-clusters)
   :stats
     (-&gt;&gt; group-clusters
       ; XXX - Base clusters may not be necessary if we use the already computed bucket vote stats
       ; A vector, where each entry is a column iterator for the matrix subset of the given group
       (mapv (comp mat/columns
                   nm/get-matrix
                   (partial nm/rowname-subset data)
                   #(clusters/group-members % base-clusters)))
       (apply
         map
         (fn [&amp; vote-cols-for-groups]
           (-&gt;&gt;
             (mapv comment-stats vote-cols-for-groups)
             (utils/mapv-rest add-comparitive-stats)))))})</pre></td></tr><tr><td class="docs"><p>Returns true if a given comment/group stat hash-map has a more representative z score than
  current-best-z. Used for making sure we have at least <em>one</em> representative comment for every group,
  even if none are left over after the more thorough filters.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- beats-best-by-test?
  [{:keys [rat rdt] :as comment-conv-stats} current-best-z]
  (or (nil? current-best-z)
      (&gt; (max rat rdt) current-best-z)))</pre></td></tr><tr><td class="docs"><p>Like beats-best-by-test?, but only considers agrees. Additionally, doesn't focus solely on repness,
  but also on raw probability of agreement, so as to ensure that there is some representation of what
  people in the group agree on. Also, note that this takes the current-best, instead of just current-best-z.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- beats-best-agr?
  [{:keys [na nd ra rat pa pat ns] :as comment-conv-stats} current-best]
  (cond
   ; Explicitly don't let something that hasn't been voted on at all come into repness
    (= 0 na nd)
        false
    ; If we have a current-best by repness estimate, use the more robust measurement
    (and current-best (&gt; (:ra current-best) 1.0))
        ; XXX - a litte messy, since we're basicaly reimplimenting the repness sort function
        (&gt; (* ra rat pa pat) (apply * (map current-best [:ra :rat :pa :pat])))
    ; If we have current-best, but only by prob estimate, just shoot for something that is generally agreed upon
    current-best
        (&gt; (* pa pat) (apply * (map current-best [:pa :pat])))
    ; Otherwise, accept if either repness or probability look generally good
    :else
        (or (stats/z-sig-90? pat)
            (and (&gt; ra 1.0)
                 (&gt; pa 0.5)))))</pre></td></tr><tr><td class="docs"><p>Decide whether we should count a given comment-conv-stat hash-map as being representative.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- passes-by-test?
  ;; Should set the significance as a input variable or env variable XXX
  [{:keys [pat rat pdt rdt] :as comment-conv-stats}]
  (or (and (stats/z-sig-90? rat) (stats/z-sig-90? pat))
      (and (stats/z-sig-90? rdt) (stats/z-sig-90? pdt))))</pre></td></tr><tr><td class="docs"><p>Formats comment/repness stats to be consumable by clients. In particular, chooses between
  agree/disagree as to which is more representative, and populates a more regular structure accordingly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn finalize-cmt-stats
  [tid {:keys [na nd ns pa pd pat pdt ra rd rat rdt] :as comment-conv-stats}]
  (let [[n-success n-trials p-success p-test repness repness-test repful-for]
         (if (&gt; rat rdt)
           [na ns pa pat ra rat :agree]
           [nd ns pd pdt rd rdt :disagree])]
    {:tid          tid
     :n-success    n-success
     :n-trials     n-trials
     :p-success    p-success
     :p-test       p-test
     :repness      repness
     :repness-test (float repness-test)
     :repful-for   repful-for}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn repness-metric
  [{:keys [repness repness-test p-success p-test]}]
  (* repness repness-test p-success p-test))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn repness-sort
  [repdata]
  (sort-by
    (comp - repness-metric)
    repdata))</pre></td></tr><tr><td class="docs"><p>Always put agrees before disagrees</p>
</td><td class="codes"><pre class="brush: clojure">(defn agrees-before-disagrees
  [repdata]
  (concat
    ; Need vector so into appends, not prepends
    (filter #(= :agree (:repful-for %)) repdata)
    (filter #(= :disagree (:repful-for %)) repdata)))</pre></td></tr><tr><td class="docs"><p>Selects representative comments based on beats-best-by-test? and passes-by-test?. Always ensures
  there is at least one representative comment for a given cluster. Takes the results of conv-repness
  and returns a map of group cluster ids to representative comments and stats.</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-rep-comments
  [{:keys [ids stats] :as repness-stats} &amp; [mod-out]]
  ; Reduce statistics into a results hash mapping group ids to rep comments
  (-&gt;&gt;
    ; reduce with indices, so we have tids
    (utils/with-indices stats)
    ; Apply moderation
    (remove (comp (set mod-out) first))
    (reduce
      (fn [result [tid stats]]
        ; Inner reduce folds data into result for each group in comment stats
        ; XXX - could this be an assoc-in?
        (reduce
          (fn [group-result [gid comment-conv-stats]]
            ; Heplper functions for building our result; abbrv. gr = group-result
            (letfn [(gr-get   [gr &amp; ks]
                      (get-in gr (into [gid] ks)))
                    (gr-assoc [gr &amp; ks-and-val]
                      (assoc-in gr (into [gid] (butlast ks-and-val)) (last ks-and-val)))]
              (as-&gt; group-result gr
                ; First check to see if the comment data passes, and add if it does
                (if (passes-by-test? comment-conv-stats)
                  (-&gt;&gt; comment-conv-stats
                       (finalize-cmt-stats tid)
                       (conj (gr-get gr :sufficient))
                       (gr-assoc gr :sufficient))
                  gr)
                ; Keep track of what the best comment so far is, even if it doesn't pass, so we always have at
                ; least one comment
                (if (and (empty? (gr-get gr :sufficient))
                         (beats-best-by-test? comment-conv-stats (gr-get gr :best :repness-test)))
                  (gr-assoc gr :best (finalize-cmt-stats tid comment-conv-stats))
                  gr)
                ; Also keep track of best agree comment is, so we can throw that the front preferentially
                (if (beats-best-agr? comment-conv-stats (gr-get gr :best-agree))
                  (gr-assoc gr :best-agree (assoc comment-conv-stats :tid tid))
                  gr))))
          result
          (utils/zip ids stats)))
      ; initialize result hash
      (into {} (map #(vector % {:best nil :best-agree nil :sufficient []}) ids)))
    ; If no sufficient, use best; otherwise sort sufficient and take 5
    (map-vals
      (fn [{:keys [best best-agree sufficient]}]
        (let [best-agree (when best-agree
                           ; finalize, and assoc in a :best-agree attribute, so the client can render
                           ; accordingly
                           (assoc (finalize-cmt-stats (:tid best-agree) best-agree)
                                  :n-agree    (:na best-agree)
                                  :best-agree true))
              ; Use best agree if that's what we have; otherwise best (possibly disagree); otherwise nothing
              best-head (cond
                          best-agree [best-agree]
                          best       [best]
                          :else      [])]
          ; If there weren't any matches of the criteria, just take the best match, and take the best agree if
          ; possible, and if not just the best general
          (if (empty? sufficient)
            best-head
            (-&gt;&gt; sufficient
                 ; Remove best agree if in list, since we'll be putting it in manually; don't need to do this
                 ; with best, since in any case we'd let it sort itself out
                 (remove #(= (:tid best-agree) (:tid %)))
                 (repness-sort) ; sort by our complicated repness metric
                 (concat (if best-agree [best-agree] [])) ; put best agree at front, if possible
                 (take 5) ; take the top 5
                 (agrees-before-disagrees))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn consensus-stats
  [data]
  (-&gt;&gt; data
       nm/get-matrix
       mat/columns
       (map comment-stats)
       (map #(assoc %2 :tid %1) (range))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn select-consensus-comments
  [cons-stats &amp; [mod-out]]
  (let [stats (-&gt;&gt; cons-stats
                   (remove (comp (set mod-out) :tid))
                   (map
                     (fn [stat]
                       (assoc stat
                              :dm (* (:pd stat) (:pdt stat))
                              :am (* (:pa stat) (:pat stat))))))
        format-stat
              (fn [cons-for stat]
                (let [[n-success p-success p-test] (if (= cons-for :agree)
                                                     [:na :pa :pat]
                                                     [:nd :pd :pdt])]
                  {:tid (:tid stat)
                   :n-success (n-success stat)
                   :n-trials (:ns stat)
                   :p-success (p-success stat)
                   :p-test (p-test stat)}))
        top-5 (fn [cons-for]
                (let [[metric prob test] (if (= cons-for :agree)
                                           [:am :pa :pat]
                                           [:dm :pd :pdt])]
                  (-&gt;&gt; stats
                       (filter #(and (&gt; (prob %) 0.5)
                                     (stats/z-sig-90? (test %))))
                       (sort-by (comp - metric))
                       (take 5)
                       (map (partial format-stat cons-for)))))]
    {:agree    (top-5 :agree)
     :disagree (top-5 :disagree)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.math.stats" name="polismath.math.stats"><h1 class="project-name">polismath.math.stats</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.math.stats
  ;; XXX Moe to require
  (:require [plumbing.core :as pc]
            [clojure.core.matrix :as matrix]
            [clojure.tools.trace :as tr]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prop-test
  [succ n]
  (let [[succ n] (map inc [succ n])]
    (* 2
       (matrix/sqrt n)
       (+ (/ succ n) -0.5))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn two-prop-test
  [succ-in succ-out pop-in pop-out]
  (let [[succ-in succ-out pop-in pop-out]
          (map inc [succ-in succ-out pop-in pop-out])
        pi1 (/ succ-in pop-in)
        pi2 (/ succ-out pop-out)
        pi-hat (/ (+ succ-in succ-out) (+ pop-in pop-out))]
    (if (= pi-hat 1)
      ; XXX - this isn't quite right... could actually solve this using limits. I think there is some theorem
      ; that lets you take the ratio of the derivatives or something...
      0
      (/ (- pi1 pi2)
         (matrix/sqrt
           (* pi-hat
              (- 1 pi-hat)
              (+ (/ 1 pop-in) (/ 1 pop-out))))))))</pre></td></tr><tr><td class="docs"><p>Test whether z-statistic is significant at %90 confidence with alternative hypothesis ></p>
</td><td class="codes"><pre class="brush: clojure">(defn z-sig-90?
  [z-val]
  (&gt; z-val 1.2816))</pre></td></tr><tr><td class="docs"><p>Test whether z-statistic is significant at %95 confidence with alternative hypothesis ></p>
</td><td class="codes"><pre class="brush: clojure">(defn z-sig-95?
  [z-val]
  (&gt; z-val 1.6449))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.meta.intercom" name="polismath.meta.intercom"><h1 class="project-name">polismath.meta.intercom</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.meta.intercom
  (:require [clj-http.client :as client]
            [plumbing.core :as pc]
            [cheshire.core :as ch]
            [korma.core :as ko]
            [korma.db :as kdb]
            ;[alex-and-georges.debug-repl :as dbr]
            [clojure.tools.logging :as log]
            [clojure.tools.trace :as tr]
            [polismath.components.env :as env]
            [polismath.utils :as utils]
            [polismath.util.pretty-printers :as pp]
            [polismath.components.db :as db]))</pre></td></tr><tr><td class="docs"><p>Get the list of users from intercom (don't want to create intercom users for users that haven't
  actually signed upGet the list of users from intercom (don't want to create intercom users for users that haven't
  actually signed upUpdate an icuser given params for that userWARNING - API not yet implemented! In theory, once it is though, this will update multiple icusers.Translates a dbuser into an icuser suitable for uploading to the intercom db.Update a single icuser record from a single dbuser record.WARNING - API not yet implemented! In theory, once it is though, this will update all users based on dbusers.Backup intercom users to json file specified by filename arg.Update intercom records by grabbing existing records, and from those the corresponding PG DB records
  so tha twe have enough information to flesh out missing information.</p>
</td><td class="codes"><pre class="brush: clojure">(comment
(def intercom-http-params
  {:accept :json
   :basic-auth [&quot;nb5hla8s&quot; (env/env :intercom-api-key)]
   :content-type :json})
(defn parse-json-resp
  [resp]
  (-&gt;&gt; resp
       :body
       ch/parse-string
       (into {})))
(defn get-icusers
  [&amp; [page]]
  (let [return-data
          (-&gt;
            (or page &quot;https://api.intercom.io/users&quot;)
            (client/get intercom-http-params)
            :body
            (ch/parse-string)
            (-&gt;&gt;
              (into {})))
        next-page (get-in return-data [&quot;pages&quot; &quot;next&quot;])
        users (get return-data &quot;users&quot;)]
    (sort-by 
      (fn [u] (int (get u &quot;created_at&quot;)))
      (if next-page
        (into users (get-icusers next-page))
        users))))
(defn get-icuser-by-email
  [email]
  (-&gt;
    (str &quot;https://api.intercom.io/users?email=&quot; email)
    (client/get intercom-http-params)
    (parse-json-resp)))
(defn update-icuser!
  [params]
  (-&gt;&gt;
    params
    (ch/generate-string)
    (assoc intercom-http-params :body)
    (client/post &quot;https://api.intercom.io/users&quot;)))
; XXX - This won't actually work yet, since they don't support updating parameters through the batch post.
; It's now written for when they do though.
(defn update-icusers!
  [users]
  (-&gt;&gt;
    users
    (assoc {} :users)
    (ch/generate-string)
    (assoc intercom-http-params :body)
    (client/post &quot;https://api.intercom.io/users/bulk&quot;)))
(defn icuser-from-dbuser
  [dbuser]
  (into
    {}
    (map
      (fn [[ic-key db-key]]
        [ic-key (db-key dbuser)])
      [[:name              :hname]
       [:user_id           :uid]
       [:email             :email]
       [:custom_attributes
          (pc/fn-&gt;
            (utils/hash-map-subset
              [:avg_n_ptpts :n_owned_convs :n_ptptd_convs :n_owned_convs_ptptd :avg_n_visitors]))]
       [:remote_created_at
          #(/ (:created %) 1000)]])))
(defn update-icuser-from-dbuser!
  [dbuser]
  (update-icuser! (icuser-from-dbuser dbuser)))
; XXX - This won't actually work yet, since they don't support updating parameters through the batch post.
; It's now written for when they do though.
(defn update-icusers-from-dbusers!
  [dbusers]
  (-&gt;&gt; dbusers
       (map icuser-from-dbuser)
       (update-icusers!)))
; Main functions:
; ===============
(defn backup-intercom-users
  [filename]
  (let [icusers (get-icusers)]
    (spit filename (ch/generate-string icusers))))
(defn future-failed? [fu]
  (try @fu false (catch Exception e true)))
(defn update-intercom-db
  []
  (let [; Get intercom users and break down by those that have id and those that don't, but have email
        _                (println &quot;Fetching data from intercom&quot;)
        icusers          (get-icusers)
        icusers-by-id    (filter #(get % &quot;user_id&quot;) icusers)
        icusers-by-email (filter #(not (get % &quot;user_id&quot;)) icusers)
        ; Get users by id, then by email for those without id, then put them all together in one collection
        _                (println &quot;Fetching pg db records&quot;)
        ;; Need to update for db component XXX
        dbusers-by-id    (db/get-users-by-uid
                           (map #(Integer/parseInt (get % &quot;user_id&quot;)) icusers-by-id))
        dbusers-by-email (db/get-users-by-email
                           (map #(get % &quot;email&quot;) icusers-by-email)) 
        all-users        (into dbusers-by-id dbusers-by-email)
        ; User updates have to be batched, since there is a limit of 240 requests per one minute. Their API
        ; suggests limiting batch size to &lt;/= 50.
        batch-size       50
        batched-users    (partition-all 50 all-users)]
    ; First some nice summary stats information
    (println &quot;Total number of intercom users:&quot; (count icusers))
    (println &quot;Number of users with valid ids:&quot; (count icusers-by-id))
    (println &quot;Number w/o:                    &quot; (count icusers-by-email))
    ; Now getting to work
    (println &quot;Now updating all user records in intercom&quot;)
    (doseq [u all-users]
      (Thread/sleep 500)
      (log/info &quot;Running update for user:&quot; (utils/hash-map-subset u [:uid :email :hname :created]))
      (try
        (update-icuser-from-dbuser! u)
        (catch Exception e
          (log/error &quot;Problem with update for user&quot; (utils/hash-map-subset u [:uid :email :hname :created]))
          (.printStackTrace e *out*))))
    ; Stab at doing batched runs
    ;(let [jobs (mapv
                 ;(fn [us]
                   ;[us
                    ;(future
                      ;(log/info &quot;Running update for&quot; (count us) &quot;users:&quot;
                               ;(map (pc/fn-&gt; (utils/hash-map-subset [:uid :email :hname :created])) us))
                      ;(update-icuser-from-dbuser! us))])
                   ;batched-users)
          ;failed-jobs (filterv (comp future-failed? second) jobs)]
      ;(println &quot;Number of failed jobs:&quot; (count failed-jobs))
      ;(println &quot;Failed for users:&quot; (apply concat (map first failed-jobs))))
    ; Call it a night
    (println &quot;Done!&quot;)
    (shutdown-agents))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.meta.metrics" name="polismath.meta.metrics"><h1 class="project-name">polismath.meta.metrics</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.meta.metrics
  (:require [clojure.tools.logging :as log]
            [com.stuartsierra.component :as component]))</pre></td></tr><tr><td class="docs"><p>Should maybe make this component depend upon mongo so that it handles both metrics that get to mongo and
those sent to graphitedb. Either that or we should rename the component and namespace graphitedb...</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Make a datagram socket; optional port parameter is the local port for the socket. If ommitted (or if nil is passed),
  the Java implementation will pick some available port and bind it.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- make-socket
	([] (new java.net.DatagramSocket))
	([port] (if port (new java.net.DatagramSocket port) (make-socket))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord MetricSender [config send-socket]
  component/Lifecycle
  (start [component]
    (log/info &quot;Starting metric sender&quot;)
    (let [send-socket (make-socket (-&gt; config :meta :graphite :local-port))]
      (assoc component :send-socket send-socket)))
  (stop [component]
    (log/info &quot;Closing metric sender&quot;)
    (.close send-socket)
    (assoc component :send-socket nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-config
  [metric-sender]
  (-&gt; metric-sender :config :meta :graphite))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- send-data
  [metric-sender data]
  (let [send-socket (:send-socket metric-sender)
        {:keys [hostname remote-port]} (get-config metric-sender)
        ipaddress (java.net.InetAddress/getByName hostname)
        send-packet (new java.net.DatagramPacket (.getBytes data) (.length data) ipaddress remote-port)]
  (.send send-socket send-packet)))</pre></td></tr><tr><td class="docs"><p>All keys are name keys are prepended with 'math.<math-env>.'...</p>
</td><td class="codes"><pre class="brush: clojure">(defn- make-send-string
  [math-env api-key values]
  (str api-key &quot;.math.&quot; math-env &quot;.&quot; (partial clojure.string/join &quot; &quot; values) \n))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- send-metric-values
  [metric-sender values]
  (let [{:keys [api-key hostname remote-port]} (get-config metric-sender)]
    (log/info &quot;sending metric data &quot; values &quot; to &quot; hostname &quot;:&quot; remote-port)
    (send-data metric-sender
               (make-send-string (-&gt; metric-sender :config :math-env)
                                 api-key
                                 values))))</pre></td></tr><tr><td class="docs"><h2>Public API</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Sends metric using metric sender, with optional timestamp attribute</p>
</td><td class="codes"><pre class="brush: clojure">(defn send-metric
  ([metric-sender name value timestamp]
   (send-metric-values metric-sender [name value timestamp]))
  ([metric-sender name value]
   (send-metric-values metric-sender [name value])))</pre></td></tr><tr><td class="docs"><p>Macro wrapping send-metric which runs a computation and sends the metrics to graphitedb</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro meter
  [metric-sender metric-name &amp; expr]
  `(let [start# (System/currentTimeMillis)
         ret# ~@expr
         end# (System/currentTimeMillis)
         duration# (- end# start#)]
     (send-metric ~metric-sender ~metric-name duration# end#)
     (log/debug (str end# &quot; &quot; ~metric-name &quot; &quot; duration# &quot; millis&quot;))
     ret#))</pre></td></tr><tr><td class="docs"><p>It looks like we can optionally get responses from graphitedb? We're not using that capability for now
though.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn receive-data [receive-socket]
(let [receive-data (byte-array 1024),
receive-packet (new java.net.DatagramPacket receive-data 1024)]
(.receive receive-socket receive-packet)
(new java.lang.String (.getData receive-packet) 0 (.getLength receive-packet))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn make-receive [receive-port]
(let [receive-socket (make-socket receive-port)]
(fn [] (receive-data receive-socket))))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.meta.microscope" name="polismath.meta.microscope"><h1 class="project-name">polismath.meta.microscope</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.meta.microscope
  (:require [polismath.conv-man :as cm]
            [polismath.components.env :as env]
            [polismath.components.db :as db]
            [polismath.math.conversation :as conv]
            [polismath.math.named-matrix :as nm]
            [polismath.utils :as utils]
            [clojure.tools.trace :as tr]
            [clojure.tools.logging :as log]
            [clojure.newtools.cli :refer [parse-opts]]
            [plumbing.core :as pc]
            [korma.core :as ko]
            [korma.db :as kdb]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn conv-poll
  [zid]
  (kdb/with-db (db/db-spec)
    (ko/select db/votes
      (ko/where {:zid zid})
      (ko/order [:zid :tid :pid :created] :asc))))</pre></td></tr><tr><td class="docs"><p>XXX Should really move to db</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-zid-from-zinvite
  [zinvite]
  (-&gt; 
    (kdb/with-db (db/db-spec)
      (ko/select &quot;zinvites&quot;
        (ko/fields :zid :zinvite)
        (ko/where {:zinvite zinvite})))
    first
    :zid))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn recompute
  [&amp; {:keys [zid zinvite recompute] :as args}]
  (assert (utils/xor zid zinvite))
  (let [zid        (or zid (get-zid-from-zinvite zinvite))
        new-votes  (conv-poll zid)
        conv-actor (cm/new-conv-actor (partial cm/load-or-init zid :recompute recompute))]
    (println zid zinvite)
    (cm/snd conv-actor [:votes new-votes])
    (add-watch
      (:conv conv-actor)
      :complete-watch
      (fn [k r o n]
        (println &quot;Done recomputing&quot;)))
    conv-actor))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn kw-&gt;int
  [kw]
  (-&gt; kw
      (str)
      (clojure.string/replace &quot;:&quot; )
      (Integer/parseInt)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn load-conv
  [&amp; {:keys [zid zinvite env-overrides] :or {env-overrides {}} :as args}]
  (assert (utils/xor zid zinvite))
  (let [zid (or zid (get-zid-from-zinvite zinvite))]
    (env/with-env-overrides env-overrides
      (-&gt;
        (db/load-conv zid)
        ;; This should be ok here right?
        (cm/restructure-mongo-conv)
        (update-in
          [:repness]
          (partial pc/map-keys kw-&gt;int))))))</pre></td></tr><tr><td class="docs"><p>Can be run as a shell command on a error file to replay what happened.</p>
</td><td class="codes"><pre class="brush: clojure">(defn replay-conv-update
  [filename]
  (let [data (conv/load-conv-update filename)
        {:keys [conv votes opts]} data
        {:keys [rating-mat base-clusters pca]} conv]
    (println &quot;Loaded conv:&quot; filename)
    (println &quot;Dimensions:&quot; (count (nm/rownames rating-mat)) &quot;x&quot; (count (nm/colnames rating-mat)))
    (conv/conv-update conv votes)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def cli-options
  [[&quot;-z&quot; &quot;--zid ZID&quot; &quot;ZID on which to do a rerun&quot; :parse-fn #(Integer/parseInt %)]
   [&quot;-Z&quot; &quot;--zinvite ZINVITE&quot; &quot;ZINVITE code on which to perform a rerun&quot;]
   [&quot;-r&quot; &quot;--recompute&quot; &quot;If set, will run a full recompute&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -main
  [&amp; args]
  (let [{:keys [options arguments errors summary]} (parse-opts args cli-options)
        conv-actor (utils/apply-kwargs recompute options)
        done? (atom false)]
    (add-watch
      (:conv conv-actor)
      :shutdown-watch
      (fn [k r o n]
        (println n)
        (swap! done? (fn [_] true))
        (shutdown-agents)))
    (loop []
      (Thread/sleep 1000)
      (when-not @done?
        (recur)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.meta.simulation" name="polismath.meta.simulation"><h1 class="project-name">polismath.meta.simulation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.meta.simulation
  (:require [polismath.math.conversation :as conversation]
            [polismath.math.named-matrix :as nm]
            [polismath.utils :as utils]
            [clojure.newtools.cli :refer [parse-opts]]
            [clojure.string :as string]
            [plumbing.core :as pc]
            [bigml.sampling [reservoir :as reservoir]
                            [simple :as simple]]
            [taoensso.timbre.profiling :as profiling :refer (pspy pspy* profile defnp p p*)]
            ;[taoensso.carmine :as car]
            ;[taoensso.carmine.message-queue :as car-mq]
            [clj-time.coerce :as time-coerce]
            [clj-time.local :as time-local]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol Voteable
  (cast-vote! [this] [this cmnt] [this member cmnt]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord CommentVoteDist
  [p-agree p-disagree]
  Voteable
  (cast-vote! [_]
    (let [r (rand)]
      (cond
        (&gt; r p-agree) -1
        (&gt; r (+ p-agree p-disagree)) 1
        :else 0))))</pre></td></tr><tr><td class="docs"><p>A somewhat bimodal random vote distribution generator. Could be more principaled about this, but I think
  it's fine for starters.</p>
</td><td class="codes"><pre class="brush: clojure">(defn comment-vote-dist!
  ([]
   (let [p1 (rand)
         p2 (rand (- 1 p1))
         p1-for-aggree (= (rand-int 2) 0)
         p-agree (if p1-for-aggree p1 p2)
         p-disagree (if p1-for-aggree p2 p1)]
     (CommentVoteDist. p-agree p-disagree)))
  ([p-agree]
   (let [p-disagree (rand (- 1 p-agree))]
     (CommentVoteDist. p-agree p-disagree)))
  ([p-agree p-disagree]
   (assert (&lt;= (+ p-agree p-disagree) 1))
   (CommentVoteDist. p-agree p-disagree)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Group
  [comment-dists]
  Voteable
  (cast-vote! [_ cmnt]
    (cast-vote! (get comment-dists cmnt))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn new-group []
  (Group. []))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn grp-add-cmnt
  [grp &amp; {:keys [dist]}]
  (update-in grp [:comment-dists] conj (or dist (comment-vote-dist!))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn random-grp-i
  [grp-dists]
  (first
    (simple/sample (range (count grp-dists))
                   :weight grp-dists)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-member
  [conv &amp; [grp-i]]
  (let [member (count (:members conv))]
    (-&gt; conv
        (update-in [:members] conj (or grp-i (random-grp-i (:grp-dists conv))))
        (update-in [:unvoted] into (for [c (range (:comments conv))] [member c])))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn conv-add-cmnt
  [conv]
  (let [cmnt (:comments conv)]
    (-&gt; conv
        (update-in [:groups] (partial mapv grp-add-cmnt))
        (update-in [:unvoted] into (for [m (range (count (:members conv)))] [m cmnt]))
        (update-in [:comments] inc))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fn-exp
  [f n]
  (apply comp (repeat n f)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-members
  [conv n]
  ((fn-exp add-member n) conv))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-cmnts
  [conv n]
  ((fn-exp conv-add-cmnt n) conv))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sim-conv
  [&amp; {:keys [zid n-grps grp-dists n-ptpts n-cmnts] :or {n-grps 3 n-ptpts 0 n-comnts 0}}]
  (-&gt; {:zid (or zid (rand-int 1000))
       :groups (repeat n-grps (new-group))
       :unvoted []
       :members [] ; actually a map of member indices to group indices
       :comments 0
       :grp-dists (or grp-dists (repeat n-grps (/ 1 n-grps)))}
      (add-members n-ptpts)
      (add-cmnts n-cmnts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn conv-votes
  [conv &amp; [n]]
  (let [n (or n 1)]
    (let [zid (:zid conv)
          picks (reservoir/sample (:unvoted conv) n)
          new-conv (update-in conv [:unvoted] (partial remove (set picks)))
          ; Handle the situation where we want more votes than there are :unvoted (ptpt, cmnt) pairs by having
          ; revotes
          picks (if (= (count picks) n)
                  picks
                  (concat picks (for [_ (range (- n (count picks)))]
                                  [(rand-int (count (:members conv)))
                                   (rand-int (:comments conv))])))
          votes (map
                  (fn [[m c]]
                    (let [grp-i (get-in conv [:members m])
                          grp ((:groups conv) grp-i)]
                      {:zid zid :pid m :tid c :vote (cast-vote! grp c)}))
                  picks)]
      ; Return the new conversation state so it can be looped on
      [new-conv votes])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol Pollable
  (poll! [this state last-vote-timestamp]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unzip
  [xys]
  (reduce
    (fn [[xs ys] xy]
      [(conj xs (first xy)) (conj ys (second xy))])
    [[] []]
    xys))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rand-ms
  [max]
  (+ (* (rand-int (int (/ max 1000)))
        1000)
     (rand-int 1000)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-timestamps
  [[conv votes] last-vote-timestamp]
  (let [old-last-ts (or last-vote-timestamp 0)
        now (System/currentTimeMillis)
        ts-diff (- now old-last-ts)]
    [conv
     (map #(assoc % :created (+ (rand-ms ts-diff) old-last-ts)) votes)]))</pre></td></tr><tr><td class="docs"><p>Takes a collection of conversation simulators, and a set of growth functions, each of which takes an argument of
  the conversation sims, and uses infomation there to decide how to modify the conversation and how to poll</p>
</td><td class="codes"><pre class="brush: clojure">(defn new-poller
  [&amp; {:keys [ptpt-growth-fn
             cmnt-growth-fn
             poll-count-fn]}]
  (reify
    Pollable
    (poll! [this conv last-vote-timestamp]
      (let [[new-ptpts new-cmnts n-votes] (map #(% conv) [ptpt-growth-fn cmnt-growth-fn poll-count-fn])]
        (-&gt; conv
            ((fn-exp add-member new-ptpts))
            ((fn-exp conv-add-cmnt new-cmnts))
            (conv-votes n-votes)
            ; Adds :created timestamps
            (add-timestamps last-vote-timestamp))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def simple-poller
  (new-poller
    :ptpt-growth-fn (fn [conv] 10)
    :cmnt-growth-fn (fn [conv] 1)
    :poll-count-fn (fn [conv]
                     (* (inc (count (:members conv))) 2))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comp-poller
  [&amp; pollers]
  (reify
    Pollable
    (poll! [this convs last-vote-timestamp]
      (let [[new-convs vote-batches]
              (unzip
                (map #(poll! %1 %2 last-vote-timestamp) pollers convs))]
        [new-convs
         (-&gt;&gt; vote-batches
              (apply concat)
              (sort-by :created))]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn int-opt [&amp; args]
  (conj (into [] args)
    :parse-fn #(Integer/parseInt %)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def cli-options
  [(int-opt &quot;-i&quot; &quot;--poll-interval INTERVAL&quot; &quot;Milliseconds between randomly generated polls&quot; :default 1000)
   (int-opt &quot;-z&quot; &quot;--n-convs NUMBER&quot; &quot;Number of conversations to simulate&quot; :default 3)
   (int-opt &quot;-p&quot; &quot;--person-count-start COUNT&quot; :default 4)
   (int-opt &quot;-P&quot; &quot;--person-count-growth COUNT&quot; :default 3)
   (int-opt &quot;-c&quot; &quot;--comment-count-start COUNT&quot; :default 3)
   (int-opt &quot;-C&quot; &quot;--comment-count-growth COUNT&quot; :default 1)
   [&quot;-h&quot; &quot;--help&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn usage [options-summary]
  (-&gt;&gt; [&quot;Polismath simulations&quot;
        &quot;Usage: lein run -m polismath.simulation [options]&quot;
        &quot;Options:&quot;
        options-summary]
   (string/join \newline)))</pre></td></tr><tr><td class="docs"><p>Just commenting out the redis/carmine specific stuff</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>See <code>wcar</code> docstring for opts
(def server1-conn {:pool {}
:spec {}})
(defmacro wcar* [&amp; body] `(car/wcar server1-conn ~@body))
(def wcar-worker* (partial car-mq/worker server1-conn))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn simulate!
[{:keys [n-convs poll-interval]}]
(let [pollers (repeat n-convs simple-poller)
poller (apply comp-poller pollers)]
(loop [convs (for [i (range n-convs)]
(sim-conv :n-ptpts 4 :n-cmnts 5 :zid i))
last-vote-timestamp 0
polls 0]
(Thread/sleep poll-interval)
(let [[new-convs votes] (poll! poller convs last-vote-timestamp)
new-last-vote-timestamp (apply max (map :created votes))]
(println "Simulating" (count votes))
(wcar* (car-mq/enqueue "simvotes" (vec votes)))
(recur new-convs new-last-vote-timestamp (inc polls))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
(simulate! {:n-convs 3 :poll-interval 3})
)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>XXX Move to a system
(defn -main [&amp; args]
(println "Starting simulations")
(let [{:keys [options arguments errors summary]} (parse-opts args cli-options)]
(cond
(:help options)   (exit 0 (usage summary))
(:errors options) (exit 1 (str "Found the following errors:" \newline (:errors options)))
:else             (simulate! options))))</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.runner" name="polismath.runner"><h1 class="project-name">polismath.runner</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>This namespace is responsible for running systems</p>
</td><td class="codes"><pre class="brush: clojure">(ns polismath.runner
  (:require [polismath.system :as system :refer [darwin-system onyx-system simulator-system]]
            [polismath.stormspec :as stormspec :refer [storm-system]]
            [polismath.utils :as utils]
            [clojure.newtools.cli :as cli]
            [clojure.tools.namespace.repl :as namespace.repl]
            [clojure.tools.logging :as log]
            [clojure.string :as string]
            [com.stuartsierra.component :as component]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce system nil)</pre></td></tr><tr><td class="docs"><p>Should build this to be an atom, and build something that intiates this state from a config file.
So when you reset, it reboots all systems.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn init!
  ([system-map-fn config-overrides]
   (alter-var-root #'system
     (constantly (utils/apply-kwargs component/system-map (system-map-fn config-overrides)))))
  ([system-map-fn]
   (init! system-map-fn {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start! []
  (alter-var-root #'system component/start))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stop! []
  (alter-var-root #'system
    (fn [s] (when s (component/stop s)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn run!
  ([system-map-fn config-overrides]
   (init! system-map-fn config-overrides)
   (start!))
  ([system-map-fn]
   (run! system-map-fn {})))</pre></td></tr><tr><td class="docs"><p>(defonce -runner! nil)</p>
</td><td class="codes"><pre class="brush: clojure">(defn -runner! [] (run! (system/base-system {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn system-reset!
  ([system-map-fn config-overrides]
   (stop!)
   (alter-var-root #'-runner! (partial run! system-map-fn config-overrides))
   ;; Not sure if this -runner! thing will work, but giving it a try. If it does we can stashthe system and
   ;; config-overrides as well.
   (namespace.repl/refresh :after 'polismath.system/runner!)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def subcommands
  {&quot;storm&quot; storm-system
   &quot;darwin&quot; darwin-system
   &quot;onyx&quot; onyx-system
   &quot;simulator&quot; simulator-system})</pre></td></tr><tr><td class="docs"><p>Has the same options as simulation if simulations are run</p>
</td><td class="codes"><pre class="brush: clojure">(def cli-options
  [[&quot;-n&quot; &quot;--name&quot; &quot;Cluster name; triggers submission to cluster&quot; :default nil]
   [&quot;-r&quot; &quot;--recompute&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn usage [options-summary]
  (-&gt;&gt; [&quot;Polismath stormspec&quot;
        &quot;Usage: lein run [subcommand] [options]&quot;
        &quot;Subcommand options: storm, darwin, onyx, simulator&quot;
        &quot;Other options:&quot;
        options-summary]
   (string/join \newline)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -main [&amp; args]
  (let [{:keys [arguments options errors summary]} (cli/parse-opts args cli-options)]
    (log/info &quot;Submitting storm topology&quot;)
    (cond
      (:help options)   (utils/exit 0 (usage summary))
      (:errors options) (utils/exit 1 (str &quot;Found the following errors:&quot; \newline (:errors options)))
      :else 
      (let [system-map-fn (subcommands (first arguments))]
        (start! system-map-fn)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (try
    (run! system/base-system)
    :ok (catch Exception e (.printStackTrace e) e))

  ;(require '[polismath.conv-man :as conv-man])
  ;(let [conv-man (:conversation-manager system)]
    ;(conv-man/queue-message-batch! conv-man ))

  (stop!)
  ;(run!
  )</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.stormspec" name="polismath.stormspec"><h1 class="project-name">polismath.stormspec</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.stormspec
  (:import [backtype.storm StormSubmitter LocalCluster])
  (:require [polismath.system :as system]
            [polismath.conv-man :as cm]
            [polismath.components.postgres :as postgres]
            [polismath.components.env :as env]
            [polismath.math.named-matrix :as nm]
            [polismath.utils :as utils]
            [polismath.math.conversation :as conv]
            ;[polismath.simulation :as sim]
            [clojure.core.matrix :as matrix]
            [clojure.string :as string]
            [clojure.tools.logging :as log]
            [clojure.core.async :as async :refer [go &lt;! &gt;! &lt;!! &gt;!! alts!! alts! chan dropping-buffer put! take!]]
            [com.stuartsierra.component :as component]
            [backtype.storm [clojure :as storm] [config :as storm-config]]
            [plumbing.core :as pc])
  ;; I don't think we need this anymore on newer Clojures, so should remove XXX
  (:gen-class))</pre></td></tr><tr><td class="docs"><p>XXX Maybe loading the current implementation can be a system boot step?
XXX - storm hack. Solves issue where one process or thread has started loading vectorz, but the other
doesn't know to wait (at least this is what seems to be the case)
(matrix/set-current-implementation :vectorz)
(matrix/matrix [[1 2 3] [4 5 6]])</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(storm/defspout poll-spout [&quot;type&quot; &quot;zid&quot; &quot;batch&quot;]
  ;; Should fork timestamp key on type as well XXX
  {:params [system-config type timestamp-key] :prepare true}
  [conf context collector]
  (let [last-timestamp (atom 0)
        ;; Need config for storm to be set under keys of :vote and :mod, so the spouts are configurable
        ;; more simply from this; But I guess some of these things should maybe not be constructable this
        ;; way...
        ;system (-&gt; system-config system/base-system component/system-map component/start)
        {:as spout-config :keys [polling-interval]} (-&gt; system-config :storm :spouts type)
        system (system/create-and-run-base-system! system-config)
        postgres (-&gt; system :postgres)]
    (storm/spout
      (nextTuple []
        (log/info &quot;Polling&quot; type &quot;&gt;&quot; @last-timestamp)
        (let [poll-function (get {:votes postgres/poll :moderation postgres/mod-poll} type)
              results (poll-function postgres @last-timestamp)
              grouped-batches (group-by :zid results)]
          ; For each chunk of votes, for each conversation, send to the appropriate spout
          (doseq [[zid batch] grouped-batches]
            (storm/emit-spout! collector [type zid batch]))
          ; Update timestamp if needed
          (swap! last-timestamp
                 (fn [last-ts] (apply max 0 last-ts (map timestamp-key results)))))
        (Thread/sleep polling-interval))
      (ack [id]))))</pre></td></tr><tr><td class="docs"><p>XXX Should build a recompute trigger spout, which just sends a recompute message type with nil batch payload</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(storm/defbolt conv-update-bolt []
  {:params [system-config] :prepare true}
  [conf context collector]
  (let [system (system/create-and-run-base-system! system-config)
        conv-man (:conversation-manager system)]
    (storm/bolt
      (execute [tuple]
        (let [[message-type zid batch] (.getValues tuple)]
          ;; XXX Need to think more about recompute...
          (cm/queue-message-batch! conv-man message-type zid batch))
        (storm/ack! collector tuple)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-topology
  ;; Note here that we're pushing through the full system configuration as config overrides, because we need
  ;; something serializable for the nodes to boot their systems from in the prepare steps
  [{:keys [config] :as storm-cluster}]
  (let [config (into {} config) ;; O/w have a non-serializable object
        spouts {&quot;vote-spout&quot; (storm/spout-spec (poll-spout config :votes :created ))
                &quot;mod-spout&quot;  (storm/spout-spec (poll-spout config :moderation :modified))}
        bolt-inputs (into {} (for [s (keys spouts)] [s [&quot;zid&quot;]]))]
    (assoc storm-cluster
           :topology
           (storm/topology
             spouts
             {&quot;conv-update&quot; (storm/bolt-spec bolt-inputs (conv-update-bolt config))}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn submit-topology!
  [storm-cluster]
  (let [{:keys [execution cluster-name workers]} (-&gt; storm-cluster :config :storm)
        cluster-submitter (case execution
                            :local (LocalCluster.)
                            :distributed (StormSubmitter.))]
    (.submitTopology cluster-submitter
                     cluster-name
                     {storm-config/TOPOLOGY-DEBUG false
                      storm-config/TOPOLOGY-WORKERS workers}
                     (:topology storm-cluster))
    (assoc storm-cluster :cluster-submitter cluster-submitter)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stop-cluster!
  [{:as storm-cluster :keys [cluster-submitter]}]
  (let [cluster-name (-&gt; storm-cluster :config :storm :cluster-name)]
    ;(.killTopology topology cluster-name)
    (.shutdown cluster-submitter)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord StormCluster [config conversation-manager topology cluster-submitter]
  component/Lifecycle
  (start [component]
    (-&gt; component
        make-topology
        submit-topology!))
  (stop [component]
    (stop-cluster! component)
    (assoc component :topology nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-storm-cluster []
  (map-&gt;StormCluster {}))</pre></td></tr><tr><td class="docs"><p>Creates a base-system and assocs in polismath storm worker related components.</p>
</td><td class="codes"><pre class="brush: clojure">(defn storm-system
  [config-overrides]
  (merge (system/base-system config-overrides)
         {:storm-cluster (component/using (create-storm-cluster) [:config :conversation-manager])}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.system" name="polismath.system"><h1 class="project-name">polismath.system</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.system
  (:require [polismath.utils :as utils]
            [polismath.components [config :as config :refer [create-config]]
                                  [mongo :as mongo :refer [create-mongo]]
                                  [postgres :as postgres :refer [create-postgres]]
                                  [core-matrix-boot :as core-matrix-boot :refer [create-core-matrix-booter]]
                                  [logger :as logger :refer [create-logger]]]
            [polismath.conv-man :as conv-man :refer [create-conversation-manager]]
            [polismath.utils :as utils]
            [clojure.tools.logging :as log]
            [clojure.tools.namespace.repl :as namespace.repl]
            [clojure.string :as string]
            [clojure.newtools.cli :as cli]
            [com.stuartsierra.component :as component]))</pre></td></tr><tr><td class="docs"><p>This constructs an instance of the base system components, including config, db, etc.</p>
</td><td class="codes"><pre class="brush: clojure">(defn base-system
  [config-overrides]
  {:config               (create-config config-overrides)
   :logger               (component/using (create-logger)               [:config])
   :core-matrix-boot     (component/using (create-core-matrix-booter)   [:config])
   :postgres             (component/using (create-postgres)             [:config])
   :mongo                (component/using (create-mongo)                [:config])
   :conversation-manager (component/using (create-conversation-manager) [:config :core-matrix-boot :mongo])
   })</pre></td></tr><tr><td class="docs"><p>Creates a base-system and assocs in darwin server related components.</p>
</td><td class="codes"><pre class="brush: clojure">(defn darwin-system
  [config-overrides]
  :TODO)</pre></td></tr><tr><td class="docs"><p>Creates a base-system and assocs in polismath onyx worker related components.</p>
</td><td class="codes"><pre class="brush: clojure">(defn onyx-system
  [config-overrides]
  :TODO)</pre></td></tr><tr><td class="docs"><p>Creates a base-system and assocs in a simulation engine.</p>
</td><td class="codes"><pre class="brush: clojure">(defn simulator-system
  [config-overrides]
  :TODO)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-and-run-base-system!
  [config]
  (-&gt;&gt; config base-system (utils/apply-kwargs component/system-map) component/start))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.util.pretty-printers" name="polismath.util.pretty-printers"><h1 class="project-name">polismath.util.pretty-printers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.util.pretty-printers
  ;; Shoud just switch to fipp
  (:require [clojure.pprint :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn str-repeat [s n]
  (apply str (repeat n s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prindent [base-indent main-indent &amp; other-strings]
  (print (str-repeat &quot; &quot; (* 2 (+ base-indent main-indent))))
  (apply println other-strings))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-repness [repness &amp; {:keys [indent] :or {indent 0}}]
  (doseq [[gid comments] repness]
    (prindent indent 0 gid)
    (doseq [c comments]
      (prindent indent 2 c))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn wide-pp [x &amp; {:keys [width] :or {width 400}}]
  (binding [*print-miser-width*  width
            *print-right-margin* width]
    (pprint x)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#polismath.utils" name="polismath.utils"><h1 class="project-name">polismath.utils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns polismath.utils
  (:use clojure.core.matrix)
  (:require [taoensso.timbre.profiling :as profiling
               :refer (pspy pspy* profile defnp p p*)]
            [clojure.core.matrix :as matrix]
            [clojure.math.numeric-tower :as math]
            [clojure.core.matrix :as mat]
            [clojure.tools.trace :as tr]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(matrix/set-current-implementation :vectorz)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn xor
  [a b]
  (and
    (or a b)
    (not (and a b))))</pre></td></tr><tr><td class="docs"><p>Round x to n demical places</p>
</td><td class="codes"><pre class="brush: clojure">(defn round-to
  [x n]
  (let [tens (math/expt 10.0 n)]
    (-&gt; (* x tens)
        (math/round)
        (/ tens))))</pre></td></tr><tr><td class="docs"><p>Like get, but gives a coll mapped from all the keys</p>
</td><td class="codes"><pre class="brush: clojure">(defn gets
  [m ks &amp; [not-found]]
  (mapv #(get m % not-found) ks))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn exit [status msg]
  (println msg)
  (System/exit status))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn agree? [n]
  (and
    (not (nil? n))
    (&lt; n 0)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn disagree? [n]
  (and
    (not (nil? n))
    (&gt; n 0)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro time2
  [tag &amp; expr]
  `(let [start# (. System (nanoTime))
         ret# ~@expr]
     (println (str (System/currentTimeMillis) &quot; &quot; ~tag &quot; &quot; (/ (double (- (. System (nanoTime)) start#)) 1000000.0) &quot; msecs&quot;))
     ret#))</pre></td></tr><tr><td class="docs"><p>Modified 'penguin' operator from plumbing.core, where do-it? is a function of the threaded value
  instead of a static value. E.g.: (->> nums (f?>> #(even? (count %)) (map inc)))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro f?&gt;&gt;
  [do-it? &amp; args]
  `(if (~do-it? ~(last args))
     (-&gt;&gt; ~(last args) ~@(butlast args))
     ~(last args)))</pre></td></tr><tr><td class="docs"><p>Modified 'penguin' operator from plumbing.core, where do-it? is a function of the threaded value
  instead of a static value. E.g.: (-> n inc (f?> even? (* 2)))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro f?&gt;
  [arg do-it? &amp; rest]
  `(if (~do-it? ~arg)
     (-&gt; ~arg ~@rest)
     ~arg))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn zip [&amp; xss]
  ;;should we redo this like the with-indices below, using a map?
  (if (&gt; (count xss) 1)
    (partition (count xss) (apply interleave xss))
    xss))</pre></td></tr><tr><td class="docs"><p>Like map, but the mapper function takes both the item and the rest of the items in the collection,
  letting you operate on each item in comparison with all the others easily</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-rest
  [f col]
  (for [i (range (count col))]
    (f (get col i)
       (concat
         (subvec col 0 i)
         (subvec col (inc i))))))</pre></td></tr><tr><td class="docs"><p>Like map-rest, but returns a vector instead of a lazy seq</p>
</td><td class="codes"><pre class="brush: clojure">(defn mapv-rest
  [f col]
  (vec (map-rest f col)))</pre></td></tr><tr><td class="docs"><p>XX This should be an env variable</p>
</td><td class="codes"><pre class="brush: clojure">(let [greedy? true]
  (defn greedy [iter]
    (if greedy?
      (into [] iter)
      iter)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn greedy-false [iter] iter)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^long typed-indexof [^java.util.List coll item]
  (.indexOf coll item))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro endlessly [interval &amp; forms]
  `(doseq [~'x (range)]
     ~@forms
     (Thread/sleep ~interval)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn with-indices [coll]
  (map #(vector %1 %2) (range) coll))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn filter-by-index [coll idxs] 
  (greedy-false
  (let [idx-set (set idxs)]
    (-&gt;&gt; (with-indices coll)
      (filter #(idx-set (first %)))
      (map second)))))</pre></td></tr><tr><td class="docs"><p>Takes a function f, any number of regular args, and a final kw-args argument which will be
  splatted in as a final argument</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply-kwargs
  [f &amp; args]
  (apply (apply partial f (butlast args)) (apply concat (last args))))</pre></td></tr><tr><td class="docs"><p>Create a new map which is given by subsetting to the given keys (ks)</p>
</td><td class="codes"><pre class="brush: clojure">(defn hash-map-subset
    [m ks]
    (let [ks (set ks)]
      (into {}
        (filter
          (fn [[k v]] (ks k))
          m))))</pre></td></tr><tr><td class="docs"><p>Handy debugging utility for loading in debugging namespaces - doesn't really always work. XXX - maybe
  use Vinyasa?</p>
</td><td class="codes"><pre class="brush: clojure">(defn use-debuggers
  []
  ;(require '[alex-and-georges.debug-repl :as dr])
  (require '[clojure.tools.trace :as tr]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn clst-trace
  ([clsts] (clst-trace  clsts))
  ([k clsts]
   (println &quot;TRACE&quot; k &quot;:&quot;)
   (doseq [c clsts]
     (println &quot;   &quot; c))
   clsts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (require '[cemerick.pomegranate :refer [add-dependencies]])
  (defn load-dep
    [dep]
    (add-dependencies :coordinates [dep] :repositories (merge cemerick.pomegranate.aether/maven-central {&quot;clojars&quot; &quot;http://clojars.org/repo&quot;})))
  (load-dep '[clj-time &quot;0.10.0&quot;])
  (load-dep '[clj-excel &quot;0.0.1&quot;]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">:ok
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/gdeer81/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_"></li><li class="floating-toc-li" id="floating-toc_polismath.components.config">polismath.components.config</li><li class="floating-toc-li" id="floating-toc_polismath.components.core-matrix-boot">polismath.components.core-matrix-boot</li><li class="floating-toc-li" id="floating-toc_polismath.components.env">polismath.components.env</li><li class="floating-toc-li" id="floating-toc_polismath.components.logger">polismath.components.logger</li><li class="floating-toc-li" id="floating-toc_polismath.components.mongo">polismath.components.mongo</li><li class="floating-toc-li" id="floating-toc_polismath.components.postgres">polismath.components.postgres</li><li class="floating-toc-li" id="floating-toc_polismath.components.random">polismath.components.random</li><li class="floating-toc-li" id="floating-toc_polismath.conv-man">polismath.conv-man</li><li class="floating-toc-li" id="floating-toc_polismath.darwin.email">polismath.darwin.email</li><li class="floating-toc-li" id="floating-toc_polismath.darwin.export">polismath.darwin.export</li><li class="floating-toc-li" id="floating-toc_polismath.darwin.server">polismath.darwin.server</li><li class="floating-toc-li" id="floating-toc_polismath.email">polismath.email</li><li class="floating-toc-li" id="floating-toc_polismath.math.clusters">polismath.math.clusters</li><li class="floating-toc-li" id="floating-toc_polismath.math.conversation">polismath.math.conversation</li><li class="floating-toc-li" id="floating-toc_polismath.math.named-matrix">polismath.math.named-matrix</li><li class="floating-toc-li" id="floating-toc_polismath.math.pca">polismath.math.pca</li><li class="floating-toc-li" id="floating-toc_polismath.math.repness">polismath.math.repness</li><li class="floating-toc-li" id="floating-toc_polismath.math.stats">polismath.math.stats</li><li class="floating-toc-li" id="floating-toc_polismath.meta.intercom">polismath.meta.intercom</li><li class="floating-toc-li" id="floating-toc_polismath.meta.metrics">polismath.meta.metrics</li><li class="floating-toc-li" id="floating-toc_polismath.meta.microscope">polismath.meta.microscope</li><li class="floating-toc-li" id="floating-toc_polismath.meta.simulation">polismath.meta.simulation</li><li class="floating-toc-li" id="floating-toc_polismath.runner">polismath.runner</li><li class="floating-toc-li" id="floating-toc_polismath.stormspec">polismath.stormspec</li><li class="floating-toc-li" id="floating-toc_polismath.system">polismath.system</li><li class="floating-toc-li" id="floating-toc_polismath.util.pretty-printers">polismath.util.pretty-printers</li><li class="floating-toc-li" id="floating-toc_polismath.utils">polismath.utils</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
SyntaxHighlighter.all();

// hackity hack
$(window).load(function() {
    var ft = $("#floating-toc");
    var ul = ft.find('ul');
    var lis = ft.find('li');
    var liHeight = $(lis.first()).height();

    ul.css('margin', '0px');
    ft.css('height', liHeight + 'px');

    showNs = function(ns) {
        var index = 0;

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i;
        }

        if(index != lastNsIndex) {
            lastNsIndex = index;
            ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300);
        }

    }

    var calcNsPositions = function() {
        var hheight = $('.docs-header').first().height();
        var nss = [];
        var anchors = [];
        var positions = [];
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1];
            nss.push(ns);
            var a = $("a[name='"+ns+"']");
            anchors.push(a);
            positions.push(a.offset().top - hheight);
            // console.log(a.offset().top)
        });

        return {nss: nss, positions: positions};
    }

    var nsPositions = calcNsPositions();
    // console.log(nsPositions)
    var lastNsIndex = -1;
    var $window = $(window);

    var currentSection = function(nsp) {
        var ps = nsp.positions;
        var scroll = $window.scrollTop();
        var nsIndex = -1;

        for(var i = 0, length = ps.length; i < length; i++) {
            if(ps[i] >= scroll) {
                nsIndex = i-1;
                break;
            }
        }

        if(nsIndex == -1) {
             if(scroll >= ps[0]) {
                 nsIndex = ps.length - 1;
             } else {
                 nsIndex = 0;
             }
        }

        return nsp.nss[nsIndex];
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions));
    });
});
</script></body></html>